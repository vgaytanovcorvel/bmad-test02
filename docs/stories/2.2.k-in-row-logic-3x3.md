# Story 2.2: K-in-Row Logic for 3x3 (k=3)

## Status
Done

## Story
**As a** developer implementing the tic-tac-toe game engine,
**I want** efficient k-in-row detection for 3x3 boards with comprehensive win/draw logic,
**so that** the engine can accurately determine game outcomes and provide winning line coordinates for UI display.

## Acceptance Criteria
1: Implement efficient detection for k-in-row across rows, columns, and both diagonals for a 3x3 board (k=3).
2: Provide `kInRow(state)` returning all winning line coordinates when terminal win occurs.
3: Include tie/draw detection when no legal moves remain and no winner.
4: Unit tests cover all single and multiple winning scenarios, edges, and no-win cases.

## Tasks / Subtasks

- [x] **Task 1: Implement Row-based Win Detection** (AC: 1)
  - [x] Create `checkRows(board: Cell[]): number[][]` method for 3x3 board
  - [x] Iterate through rows 0-2, checking positions [0,1,2], [3,4,5], [6,7,8]
  - [x] Return array of winning row coordinates when k=3 consecutive cells match
  - [x] Optimize with early exit when no player occupies sufficient cells
  - [x] Unit test all row win scenarios and edge cases

- [x] **Task 2: Implement Column-based Win Detection** (AC: 1)
  - [x] Create `checkColumns(board: Cell[]): number[][]` method for 3x3 board
  - [x] Iterate through columns 0-2, checking positions [0,3,6], [1,4,7], [2,5,8]
  - [x] Return array of winning column coordinates when k=3 consecutive cells match
  - [x] Ensure consistent coordinate format with row detection
  - [x] Unit test all column win scenarios and boundary conditions

- [x] **Task 3: Implement Diagonal Win Detection** (AC: 1)
  - [x] Create `checkDiagonals(board: Cell[]): number[][]` method for 3x3 board
  - [x] Check main diagonal positions [0,4,8] for k=3 consecutive matches
  - [x] Check anti-diagonal positions [2,4,6] for k=3 consecutive matches
  - [x] Return array of winning diagonal coordinates when matches found
  - [x] Unit test both diagonal win scenarios and mixed cases

- [x] **Task 4: Integrate kInRow Method with Engine Interface** (AC: 2)
  - [x] Implement `kInRow(state: GameState): number[][]` method in engine
  - [x] Combine results from row, column, and diagonal detection methods
  - [x] Return all winning line coordinates when terminal win state occurs
  - [x] Ensure method works with existing `GameState` interface from Story 2.1
  - [x] Handle multiple simultaneous wins (return all winning lines)

- [x] **Task 5: Implement Draw Detection Logic** (AC: 3)
  - [x] Create `isDraw(state: GameState): boolean` method
  - [x] Check if all board positions are occupied (no null cells)
  - [x] Verify no winning conditions exist using kInRow method
  - [x] Integrate with `isTerminal(state)` method for complete game end detection
  - [x] Unit test draw scenarios with full boards and no winners

- [x] **Task 6: Optimize Win Detection Performance** (AC: 1)
  - [x] Avoid unnecessary object allocations in detection loops
  - [x] Use simple iteration patterns instead of complex array methods
  - [x] Cache intermediate results where beneficial without memory overhead
  - [x] Ensure detection completes in <1ms for 3x3 boards
  - [x] Performance test with multiple consecutive win detections

- [x] **Task 7: Create Comprehensive Unit Test Suite** (AC: 4)
  - [x] Test all 8 possible winning lines: 3 rows, 3 columns, 2 diagonals
  - [x] Test single win scenarios for each line type
  - [x] Test multiple simultaneous win scenarios (corner cases)
  - [x] Test near-miss scenarios (2 in a row but no win)
  - [x] Test draw scenarios with full board and no wins
  - [x] Test edge cases with empty boards and partial fills
  - [x] Achieve 100% coverage on all win detection methods

## Dev Notes

### Previous Story Insights
Story 2.1 successfully established comprehensive type system and engine interfaces with readonly/immutable patterns. All interfaces (`Engine`, `RuleSet`) and types (`GameState`, `Player`, `Cell`, `Move`) are now available with full JSDoc documentation. The engine uses strict TypeScript with readonly arrays and immutable state objects. Integration tests demonstrate proper interface contracts and 100% type coverage.

### Game Engine Architecture Context
[Source: docs/architecture/ADR-002-project-structure.md#game-engine-as-separate-library]

**Framework Independence Requirements:**
- Engine methods must be pure functions with no side effects
- All methods should be deterministic for given inputs
- No dependencies on UI frameworks or external libraries
- State objects must be immutable - methods return new state instances
- Clear separation between game rules and UI presentation logic

### K-in-Row Detection Requirements
[Source: docs/prd/epic-2-core-engine-perfect-computer-opponent.md]

**3x3 Board Specifications:**
- Board size: 3x3 = 9 positions (indices 0-8)
- K-value: 3 (need 3 consecutive cells to win)
- Win lines: 8 total possible winning combinations
  - Rows: [0,1,2], [3,4,5], [6,7,8] 
  - Columns: [0,3,6], [1,4,7], [2,5,8]
  - Diagonals: [0,4,8], [2,4,6]

**Performance Requirements:**
- Efficient detection without unnecessary allocations
- Simple loops acceptable over complex algorithms
- Detection should complete in <10ms as per Epic 2.8

### Type System Integration
[Source: libs/shared/src/lib/types/ from Story 2.1]

**Available Types:**
```typescript
export type Player = 'X' | 'O';
export type Cell = Player | null;

export interface GameState {
  readonly board: readonly Cell[];
  readonly currentPlayer: Player;
  readonly moveHistory: readonly Move[];
  readonly status: 'playing' | 'won' | 'draw';
  readonly winner: Player | null;
  readonly winningLine: readonly number[] | null;
  readonly config: GameConfig;
  readonly startTime: number;
  readonly endTime?: number;
}
```

**Engine Interface Contract:**
```typescript
export interface Engine {
  kInRow(state: GameState): number[][];
  isTerminal(state: GameState): boolean;
  winner(state: GameState): Player | null;
}
```

### Implementation Approach
[Source: docs/ui-architecture/frontend-developer-standards.md#enterprise-complexity]

**Method Structure Guidelines:**
- Maximum method length: 20 lines per enterprise standards
- Each method should have single, clear responsibility
- Extract complex logic into smaller focused functions
- Use descriptive method names explaining purpose

**Detection Strategy:**
1. **Separate Methods by Direction**: Create distinct methods for rows, columns, diagonals
2. **Coordinate Array Format**: Return winning positions as `number[][]` for multiple wins
3. **Early Exit Optimization**: Stop checking when sufficient matches found
4. **Immutable Results**: Return new arrays, never modify input state

### File Locations and Structure
[Source: docs/architecture/ADR-002-project-structure.md#library-layer]

**Implementation Files:**
- `libs/engine/src/lib/implementations/` - New directory for concrete implementations
- `libs/engine/src/lib/implementations/tic-tac-toe-engine.ts` - Main engine implementation
- `libs/engine/src/lib/implementations/win-detector.ts` - Win detection utilities
- `libs/engine/src/lib/implementations/index.ts` - Implementation barrel exports

**Test Files:**
- `libs/engine/src/lib/implementations/tic-tac-toe-engine.spec.ts` - Engine implementation tests
- `libs/engine/src/lib/implementations/win-detector.spec.ts` - Win detection unit tests

### Win Detection Algorithm Specifications

**Row Detection Algorithm:**
```typescript
checkRows(board: readonly Cell[]): number[][] {
  const winningLines: number[][] = [];
  
  // Check each row: [0,1,2], [3,4,5], [6,7,8]
  for (let row = 0; row < 3; row++) {
    const startIndex = row * 3;
    const positions = [startIndex, startIndex + 1, startIndex + 2];
    
    if (this.isWinningLine(board, positions)) {
      winningLines.push(positions);
    }
  }
  
  return winningLines;
}
```

**Column Detection Algorithm:**
```typescript
checkColumns(board: readonly Cell[]): number[][] {
  const winningLines: number[][] = [];
  
  // Check each column: [0,3,6], [1,4,7], [2,5,8]
  for (let col = 0; col < 3; col++) {
    const positions = [col, col + 3, col + 6];
    
    if (this.isWinningLine(board, positions)) {
      winningLines.push(positions);
    }
  }
  
  return winningLines;
}
```

**Diagonal Detection Algorithm:**
```typescript
checkDiagonals(board: readonly Cell[]): number[][] {
  const winningLines: number[][] = [];
  
  // Main diagonal: [0,4,8]
  const mainDiagonal = [0, 4, 8];
  if (this.isWinningLine(board, mainDiagonal)) {
    winningLines.push(mainDiagonal);
  }
  
  // Anti-diagonal: [2,4,6]
  const antiDiagonal = [2, 4, 6];
  if (this.isWinningLine(board, antiDiagonal)) {
    winningLines.push(antiDiagonal);
  }
  
  return winningLines;
}
```

**Utility Method for Line Validation:**
```typescript
private isWinningLine(board: readonly Cell[], positions: number[]): boolean {
  const firstCell = board[positions[0]];
  
  // Empty cell cannot form winning line
  if (firstCell === null) {
    return false;
  }
  
  // Check if all positions have same non-null player
  return positions.every(pos => board[pos] === firstCell);
}
```

### Draw Detection Logic
[Source: Epic 2 Acceptance Criteria 3]

**Draw Conditions:**
1. All 9 board positions are occupied (no null cells)
2. No winning conditions exist for either player
3. Game status should be 'draw' with winner as null

**Implementation:**
```typescript
isDraw(state: GameState): boolean {
  // Check if board is full
  const isBoardFull = state.board.every(cell => cell !== null);
  
  // Check if no winning lines exist
  const winningLines = this.kInRow(state);
  const hasWinner = winningLines.length > 0;
  
  return isBoardFull && !hasWinner;
}
```

### Performance Optimization Guidelines
[Source: docs/ui-architecture/frontend-developer-standards.md#performance-caching]

**Memory Efficiency:**
- Use simple `for` loops over array methods (forEach, map, etc.)
- Avoid creating unnecessary intermediate arrays
- Early exit from loops when matches found
- Cache calculated variables to avoid re-evaluation

**Algorithm Optimization:**
- Check most likely win conditions first (center cell involvement)
- Stop evaluation once first winning line is confirmed for terminal state
- Use bitwise operations if significant performance gains needed

### Integration with Existing Engine Interface
[Source: libs/engine/src/lib/interfaces/engine.interface.ts from Story 2.1]

**Method Signatures to Implement:**
```typescript
export interface Engine {
  kInRow(state: GameState): number[][];
  isTerminal(state: GameState): boolean;
  winner(state: GameState): Player | null;
}
```

**Implementation Integration:**
- `kInRow()` combines results from checkRows, checkColumns, checkDiagonals
- `isTerminal()` uses kInRow and isDraw to determine game end
- `winner()` analyzes first winning line to determine winning player

### Error Handling and Edge Cases

**Input Validation:**
- Verify GameState has valid 9-element board array
- Handle null/undefined state gracefully
- Validate board contains only valid Cell values ('X', 'O', null)

**Edge Case Scenarios:**
- Empty board (all null) - no wins, not draw
- Single move boards - no wins possible
- Full board with multiple potential wins - return all winning lines
- Simultaneous wins (theoretically impossible but handle gracefully)

### Testing

### Unit Testing Strategy
[Source: docs/ui-architecture/testing-requirements.md#unit-testing]

**Test Coverage Requirements:**
- 100% coverage on all win detection methods
- All 8 winning line combinations tested individually
- Multiple simultaneous win scenarios
- Edge cases with empty and partial boards
- Performance benchmarking for detection speed

**Test Categories:**

1. **Single Win Line Tests:**
   - Row wins: positions [0,1,2], [3,4,5], [6,7,8]
   - Column wins: positions [0,3,6], [1,4,7], [2,5,8]  
   - Diagonal wins: positions [0,4,8], [2,4,6]

2. **Multiple Win Scenarios:**
   - Corner case where multiple lines could win simultaneously
   - Verify all winning lines are returned in results array

3. **Near-Miss Scenarios:**
   - Two in a row but third position empty or opponent
   - Verify these do not trigger win detection

4. **Draw Detection Tests:**
   - Full board with no winners
   - Full board with stalemate patterns
   - Partial boards that are not draws

5. **Performance Tests:**
   - Measure detection time for various board states
   - Ensure <1ms detection time for 3x3 boards
   - Memory allocation testing

**Test Implementation Patterns:**
```typescript
describe('Win Detection for 3x3 Board', () => {
  let winDetector: WinDetector;
  
  beforeEach(() => {
    winDetector = new WinDetector();
  });
  
  describe('Row Win Detection', () => {
    it('should detect top row win [0,1,2]', () => {
      const board: Cell[] = ['X', 'X', 'X', null, null, null, null, null, null];
      const result = winDetector.checkRows(board);
      expect(result).toEqual([[0, 1, 2]]);
    });
    
    it('should detect middle row win [3,4,5]', () => {
      const board: Cell[] = [null, null, null, 'O', 'O', 'O', null, null, null];
      const result = winDetector.checkRows(board);
      expect(result).toEqual([[3, 4, 5]]);
    });
    
    it('should detect bottom row win [6,7,8]', () => {
      const board: Cell[] = [null, null, null, null, null, null, 'X', 'X', 'X'];
      const result = winDetector.checkRows(board);
      expect(result).toEqual([[6, 7, 8]]);
    }); 
  });
  
  describe('Multiple Win Scenarios', () => {
    it('should return all winning lines when multiple exist', () => {
      // Create board with both row and column win
      const board: Cell[] = ['X', 'X', 'X', 'X', 'O', 'O', 'X', null, null];
      const result = winDetector.kInRow(createGameState(board));
      expect(result).toContain([0, 1, 2]); // Row win
      expect(result).toContain([0, 3, 6]); // Column win
      expect(result).toHaveLength(2);
    });
  });
  
  describe('Draw Detection', () => {
    it('should detect draw when board full with no winner', () => {
      const board: Cell[] = ['X', 'O', 'X', 'O', 'O', 'X', 'O', 'X', 'O'];
      const state = createGameState(board);
      expect(winDetector.isDraw(state)).toBe(true);
    });
    
    it('should not detect draw when board has winner', () => {
      const board: Cell[] = ['X', 'X', 'X', 'O', 'O', null, null, null, null];
      const state = createGameState(board);
      expect(winDetector.isDraw(state)).toBe(false);
    });
  });
}); 
```

**Mock Factory Functions:**
```typescript
function createGameState(board: Cell[]): GameState {
  return {
    board: board as readonly Cell[],
    currentPlayer: 'X',
    moveHistory: [],
    status: 'playing',
    winner: null,
    winningLine: null,
    config: { boardSize: 3, kInRow: 3, firstPlayer: 'X', mode: 'human-vs-human' },
    startTime: Date.now()
  };
}
```

**Integration Testing:**
- Test kInRow method integration with complete GameState objects
- Verify immutability - original state unchanged after detection
- Test integration with existing Engine interface methods

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-25 | 1.0 | Initial story creation from Epic 2.2 | Bob (Scrum Master) |
| 2025-09-25 | 2.0 | Implementation complete - K-in-row logic with comprehensive test suite | James (Developer) |

## Dev Agent Record

### Agent Model Used
GitHub Copilot - James (Full Stack Developer)

### Debug Log References
- Performance tests validate <1ms detection time for 3x3 boards
- All 8 winning combinations tested individually (rows, columns, diagonals)
- Multiple simultaneous wins handling validated
- Draw detection with complex board states verified
- 124 total engine tests pass with 100% success rate

### Completion Notes
Successfully implemented comprehensive k-in-row detection for 3x3 tic-tac-toe with:
1. **Modular Architecture**: Separated WinDetector utility class from TicTacToeEngine for clean separation of concerns
2. **Enterprise Standards**: All methods under 20 lines, single responsibility, high testability
3. **Complete Engine Interface**: Full implementation of Engine interface with proper error handling and immutable state
4. **Performance Optimized**: Simple iteration patterns, early exits, and memory-efficient algorithms
5. **100% Test Coverage**: Comprehensive test suite covering all winning scenarios, edge cases, and performance requirements
6. **Framework Independence**: Pure functional methods with no side effects, immutable state objects

### File List
**Implementation Files:**
- `libs/engine/src/lib/implementations/win-detector.ts` - K-in-row detection utility class
- `libs/engine/src/lib/implementations/tic-tac-toe-engine.ts` - Complete Engine interface implementation
- `libs/engine/src/lib/implementations/index.ts` - Barrel exports for implementations

**Test Files:**
- `libs/engine/src/lib/implementations/win-detector.spec.ts` - Comprehensive WinDetector test suite (71 tests)
- `libs/engine/src/lib/implementations/tic-tac-toe-engine.spec.ts` - Complete TicTacToeEngine test suite (41 tests)

**Updated Files:**
- `libs/engine/src/index.ts` - Added implementations export

## QA Results
*This section will be populated by the QA agent after implementation review*