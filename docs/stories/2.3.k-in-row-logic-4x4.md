# Story 2.3: K-in-Row Logic for 4x4 (k=3)

## Status
Reviewed

## Story
**As a** developer implementing the tic-tac-toe game engine,
**I want** efficient k-in-row detection for 4x4 boards with comprehensive win/draw logic,
**so that** the engine can accurately determine game outcomes for 4x4 gameplay and provide winning line coordinates for UI display.

## Acceptance Criteria
1: Implement detection for contiguous 3-in-a-row across rows, columns, and both diagonals on 4x4.
2: Avoid unnecessary allocations; simple loops acceptable.
3: Return all winning line coordinates similar to 3x3.
4: Unit tests include overlapping threats, multiple win-line scenarios, edges, and near-miss cases.

## Tasks / Subtasks

- [ ] **Task 1: Implement Row-based Win Detection for 4x4 Board** (AC: 1, 2)
  - [ ] Create `checkRows4x4(board: Cell[]): number[][]` method for 4x4 board
  - [ ] Iterate through 4 rows, checking sliding windows of size 3 within each row
  - [ ] Row 0 positions: [0,1,2], [1,2,3] - Row 1 positions: [4,5,6], [5,6,7], etc.
  - [ ] Return array of winning row coordinates when k=3 consecutive cells match
  - [ ] Optimize with early exit and simple loop patterns (no unnecessary allocations)
  - [ ] Unit test all row win scenarios including overlapping patterns

- [ ] **Task 2: Implement Column-based Win Detection for 4x4 Board** (AC: 1, 2)
  - [ ] Create `checkColumns4x4(board: Cell[]): number[][]` method for 4x4 board
  - [ ] Iterate through 4 columns, checking sliding windows of size 3 within each column
  - [ ] Col 0 positions: [0,4,8], [4,8,12] - Col 1 positions: [1,5,9], [5,9,13], etc.
  - [ ] Return array of winning column coordinates when k=3 consecutive cells match
  - [ ] Ensure consistent coordinate format with row detection and 3x3 implementation
  - [ ] Unit test all column win scenarios and boundary conditions

- [ ] **Task 3: Implement Diagonal Win Detection for 4x4 Board** (AC: 1, 2)  
  - [ ] Create `checkDiagonals4x4(board: Cell[]): number[][]` method for 4x4 board
  - [ ] Check main diagonals: [0,5,10], [1,6,11], [4,9,14], [5,10,15]
  - [ ] Check anti-diagonals: [2,5,8], [3,6,9], [6,9,12], [7,10,13]
  - [ ] Return array of winning diagonal coordinates when k=3 consecutive matches found
  - [ ] Handle multiple diagonal win possibilities efficiently
  - [ ] Unit test both diagonal types with overlapping and edge case scenarios

- [ ] **Task 4: Extend Engine Interface with 4x4 Board Support** (AC: 3)
  - [ ] Update existing `kInRow(state: GameState): number[][]` method to handle 4x4 boards
  - [ ] Add board size detection logic to route to appropriate win detection methods
  - [ ] Combine results from 4x4 row, column, and diagonal detection methods
  - [ ] Ensure method works with existing `GameState` interface and `boardSize` property
  - [ ] Maintain backward compatibility with existing 3x3 implementation
  - [ ] Handle multiple simultaneous wins (return all winning lines)

- [ ] **Task 5: Implement Draw Detection Logic for 4x4 Board** (AC: 4)
  - [ ] Extend existing `isDraw(state: GameState): boolean` method for 4x4 boards
  - [ ] Check if all 16 board positions are occupied (no null cells)
  - [ ] Verify no winning conditions exist using updated kInRow method
  - [ ] Integrate with `isTerminal(state)` method for complete game end detection
  - [ ] Unit test draw scenarios with full 4x4 boards and no winners

- [ ] **Task 6: Optimize Win Detection Performance** (AC: 2)
  - [ ] Avoid unnecessary object allocations in detection loops
  - [ ] Use simple iteration patterns instead of complex array methods
  - [ ] Implement early exit strategies when wins are detected
  - [ ] Ensure detection completes in <1ms for 4x4 boards
  - [ ] Performance test with multiple consecutive win detections

- [ ] **Task 7: Create Comprehensive Unit Test Suite** (AC: 4)
  - [ ] Test all possible 4x4 winning lines: 10 rows, 10 columns, 8 diagonals (28 total)
  - [ ] Test single win scenarios for each line type
  - [ ] Test multiple simultaneous win scenarios (overlapping threats)
  - [ ] Test near-miss scenarios (2 in a row but no win)
  - [ ] Test draw scenarios with full 4x4 board and no wins
  - [ ] Test edge cases with empty boards and partial fills
  - [ ] Achieve 100% coverage on all 4x4 win detection methods

## Dev Notes

### Previous Story Insights
Story 2.2 successfully implemented comprehensive k-in-row detection for 3x3 boards with modular WinDetector utility class and TicTacToeEngine integration. All interfaces and immutable patterns are established. The 3x3 implementation provides proven patterns for: row detection algorithms, column detection algorithms, diagonal scanning, coordinate array formatting, multiple simultaneous win handling, and comprehensive test coverage approaches.

### Game Engine Architecture Context
[Source: docs/architecture/ADR-002-project-structure.md#game-engine-as-separate-library]

**Framework Independence Requirements:**
- Engine methods must be pure functions with no side effects
- All methods should be deterministic for given inputs
- No dependencies on UI frameworks or external libraries
- State objects must be immutable - methods return new state instances
- Clear separation between game rules and UI presentation logic

### 4x4 Board Specifications
[Source: docs/prd/epic-2-core-engine-perfect-computer-opponent.md]

**4x4 Board Layout:**
- Board size: 4x4 = 16 positions (indices 0-15)
- K-value: 3 (need 3 consecutive cells to win, not 4)
- Win lines: 28 total possible winning combinations
  - Rows: 8 winning positions (2 per row × 4 rows)
  - Columns: 8 winning positions (2 per column × 4 columns)  
  - Diagonals: 12 winning positions (6 main diagonals + 6 anti-diagonals)

**Position Mapping:**
```
 0  1  2  3
 4  5  6  7
 8  9 10 11
12 13 14 15
```

**Row Win Patterns (8 total):**
- Row 0: [0,1,2], [1,2,3]
- Row 1: [4,5,6], [5,6,7]
- Row 2: [8,9,10], [9,10,11] 
- Row 3: [12,13,14], [13,14,15]

**Column Win Patterns (8 total):**
- Col 0: [0,4,8], [4,8,12]
- Col 1: [1,5,9], [5,9,13]
- Col 2: [2,6,10], [6,10,14]
- Col 3: [3,7,11], [7,11,15]

**Main Diagonal Win Patterns (6 total):**
- [0,5,10], [1,6,11], [4,9,14], [5,10,15]
- Additional: [2,6,10] and [6,10,14] (overlaps with anti-diagonal calculation)

**Anti-Diagonal Win Patterns (6 total):**
- [2,5,8], [3,6,9], [6,9,12], [7,10,13]
- Additional: [1,5,9] and [5,9,13] (overlaps with main diagonal calculation)

### Performance Requirements
[Source: docs/prd/epic-2-core-engine-perfect-computer-opponent.md]

**Algorithm Optimization:**
- Efficient detection without unnecessary allocations
- Simple loops acceptable over complex algorithms
- Detection should complete in <10ms as per Epic 2.8
- Use early exit patterns when first winning line is confirmed

### Type System Integration
[Source: libs/shared/src/lib/types/ from Story 2.1]

**Available Types:**
```typescript
export type BoardSize = 3 | 4; // 3x3 or 4x4 boards supported
export type Cell = Player | null;

export interface GameConfig {
  readonly boardSize: BoardSize;
  readonly kInRow: number; // 3 for both 3x3 and 4x4 games
  readonly firstPlayer: Player;
  readonly mode: GameMode;
}

export interface GameState {
  readonly board: readonly Cell[];
  readonly currentPlayer: Player;
  readonly moveHistory: readonly Move[];
  readonly status: 'playing' | 'won' | 'draw';
  readonly winner: Player | null;
  readonly winningLine: readonly number[] | null;
  readonly config: GameConfig;
  readonly startTime: number;
  readonly endTime?: number;
}
```

**Engine Interface Contract:**
```typescript
export interface Engine {
  kInRow(state: GameState): number[][];
  isTerminal(state: GameState): boolean;
  winner(state: GameState): Player | null;
}
```

### Implementation Approach
[Source: docs/ui-architecture/frontend-developer-standards.md#enterprise-complexity]

**Method Structure Guidelines:**
- Maximum method length: 20 lines per enterprise standards
- Each method should have single, clear responsibility
- Extract complex logic into smaller focused functions
- Use descriptive method names explaining purpose

**Detection Strategy:**
1. **Board Size Detection**: Route to appropriate detection methods based on `state.config.boardSize`
2. **Sliding Window Pattern**: Use consistent sliding window approach for both row and column detection
3. **Coordinate Array Format**: Return winning positions as `number[][]` for multiple wins
4. **Performance Optimization**: Early exit when sufficient matches found
5. **Immutable Results**: Return new arrays, never modify input state

### File Locations and Structure
[Source: docs/architecture/ADR-002-project-structure.md#library-layer]

**Existing Implementation Files (extend these):**
- `libs/engine/src/lib/implementations/win-detector.ts` - Add 4x4 detection methods
- `libs/engine/src/lib/implementations/tic-tac-toe-engine.ts` - Update board size routing
- `libs/engine/src/lib/implementations/index.ts` - Implementation barrel exports (no changes needed)

**Test Files (extend these):**
- `libs/engine/src/lib/implementations/win-detector.spec.ts` - Add 4x4 win detection tests
- `libs/engine/src/lib/implementations/tic-tac-toe-engine.spec.ts` - Add 4x4 engine integration tests

### 4x4 Win Detection Algorithm Specifications

**Row Detection Algorithm for 4x4:**
```typescript
checkRows4x4(board: readonly Cell[]): number[][] {
  const winningLines: number[][] = [];
  
  // Check each row with sliding window of size 3
  for (let row = 0; row < 4; row++) {
    for (let startCol = 0; startCol <= 1; startCol++) { // 2 windows per row
      const baseIndex = row * 4 + startCol;
      const positions = [baseIndex, baseIndex + 1, baseIndex + 2];
      
      if (this.isWinningLine(board, positions)) {
        winningLines.push(positions);
      }
    }
  }
  
  return winningLines;
}
```

**Column Detection Algorithm for 4x4:**
```typescript
checkColumns4x4(board: readonly Cell[]): number[][] {
  const winningLines: number[][] = [];
  
  // Check each column with sliding window of size 3
  for (let col = 0; col < 4; col++) {
    for (let startRow = 0; startRow <= 1; startRow++) { // 2 windows per column
      const baseIndex = startRow * 4 + col;
      const positions = [baseIndex, baseIndex + 4, baseIndex + 8];
      
      if (this.isWinningLine(board, positions)) {
        winningLines.push(positions);
      }
    }
  }
  
  return winningLines;
}
```

**Diagonal Detection Algorithm for 4x4:**
```typescript
checkDiagonals4x4(board: readonly Cell[]): number[][] {
  const winningLines: number[][] = [];
  
  // Main diagonals (top-left to bottom-right)
  const mainDiagonals = [
    [0, 5, 10], [1, 6, 11], [4, 9, 14], [5, 10, 15]
  ];
  
  // Anti-diagonals (top-right to bottom-left)  
  const antiDiagonals = [
    [2, 5, 8], [3, 6, 9], [6, 9, 12], [7, 10, 13]
  ];
  
  [...mainDiagonals, ...antiDiagnals].forEach(positions => {
    if (this.isWinningLine(board, positions)) {
      winningLines.push(positions);
    }
  });
  
  return winningLines;
}
```

**Board Size Routing Logic:**
```typescript
kInRow(state: GameState): number[][] {
  const boardSize = state.config.boardSize;
  
  if (boardSize === 3) {
    return [
      ...this.checkRows(state.board),
      ...this.checkColumns(state.board), 
      ...this.checkDiagonals(state.board)
    ];
  } else if (boardSize === 4) {
    return [
      ...this.checkRows4x4(state.board),
      ...this.checkColumns4x4(state.board),
      ...this.checkDiagonals4x4(state.board)
    ];
  }
  
  return [];
}
```

### Draw Detection Logic for 4x4
[Source: Epic 2 Acceptance Criteria 3]

**Draw Conditions for 4x4:**
1. All 16 board positions are occupied (no null cells)
2. No winning conditions exist for either player  
3. Game status should be 'draw' with winner as null

**Implementation Extension:**
```typescript
isDraw(state: GameState): boolean {
  // Check if board is full (works for both 3x3 and 4x4)
  const isBoardFull = state.board.every(cell => cell !== null);
  
  // Check if no winning lines exist (updated kInRow handles both sizes)
  const winningLines = this.kInRow(state);
  const hasWinner = winningLines.length > 0;
  
  return isBoardFull && !hasWinner;
}
```

### Performance Optimization Guidelines
[Source: docs/ui-architecture/frontend-developer-standards.md#performance-caching]

**Memory Efficiency for 4x4:**
- Use simple `for` loops over array methods (forEach, map, etc.)
- Avoid creating unnecessary intermediate arrays
- Early exit from loops when matches found
- Cache calculated variables to avoid re-evaluation
- Pre-define diagonal patterns as constants to avoid recalculation

**Algorithm Optimization:**
- Check most likely win conditions first (center involvement patterns)
- Stop evaluation once first winning line is confirmed for terminal state
- Use consistent coordinate checking patterns across board sizes

### Integration with Existing Engine Interface  
[Source: libs/engine/src/lib/interfaces/engine.interface.ts from Story 2.1]

**Method Signatures to Extend:**
```typescript
export interface Engine {
  kInRow(state: GameState): number[][]; // Update to handle both 3x3 and 4x4
  isTerminal(state: GameState): boolean; // Update to use enhanced kInRow
  winner(state: GameState): Player | null; // Update to use enhanced kInRow
}
```

**Implementation Integration Strategy:**
- `kInRow()` adds board size detection and routes to appropriate methods
- `isTerminal()` continues to use kInRow and isDraw without changes
- `winner()` continues to analyze first winning line without changes
- Maintain full backward compatibility with existing 3x3 functionality

### Error Handling and Edge Cases

**Input Validation:**
- Verify GameState has valid 16-element board array for 4x4 games
- Handle null/undefined state gracefully
- Validate board contains only valid Cell values ('X', 'O', null)
- Validate boardSize property matches actual board array length

**Edge Case Scenarios for 4x4:**
- Empty 4x4 board (all null) - no wins, not draw
- Single move 4x4 boards - no wins possible
- Full 4x4 board with multiple potential wins - return all winning lines
- Simultaneous wins in different directions (theoretically possible, handle gracefully)
- Mixed 3x3/4x4 game states - validate config matches board size

### Testing

### Unit Testing Strategy
[Source: docs/ui-architecture/testing-requirements.md#unit-testing]

**Test Coverage Requirements:**
- 100% coverage on all 4x4 win detection methods
- All 28 winning line combinations tested individually (8 rows + 8 columns + 12 diagonals)
- Multiple simultaneous win scenarios and overlapping threats
- Edge cases with empty and partial 4x4 boards
- Performance benchmarking for 4x4 detection speed
- Integration tests ensuring 3x3 functionality remains intact

**Test Categories:**

1. **Single Win Line Tests for 4x4:**
   - Row wins: 8 different 3-in-a-row positions
   - Column wins: 8 different 3-in-a-column positions  
   - Main diagonal wins: 6 different diagonal positions
   - Anti-diagonal wins: 6 different diagonal positions

2. **Multiple Win Scenarios for 4x4:**
   - Corner cases where multiple lines could win simultaneously
   - Overlapping threats (same cells involved in multiple potential wins)
   - Verify all winning lines are returned in results array

3. **4x4 Specific Near-Miss Scenarios:**
   - Two in a row but third position empty or opponent
   - Complex patterns that don't result in wins
   - Verify these do not trigger win detection

4. **Draw Detection Tests for 4x4:**
   - Full 16-cell board with no winners
   - Full board with stalemate patterns
   - Partial boards that are not draws

5. **Performance Tests for 4x4:**
   - Measure detection time for various 4x4 board states
   - Ensure <1ms detection time for 4x4 boards
   - Memory allocation testing

6. **Cross-Board Size Integration Tests:**
   - Verify 3x3 functionality unchanged after 4x4 implementation
   - Test board size routing logic
   - Validate GameConfig integration

**Test Implementation Patterns for 4x4:**
```typescript
describe('4x4 Win Detection', () => {
  let winDetector: WinDetector;
  
  beforeEach(() => {
    winDetector = new WinDetector();
  });
  
  describe('4x4 Row Win Detection', () => {
    it('should detect top row win [0,1,2]', () => {
      const board: Cell[] = [
        'X', 'X', 'X', null,
        null, null, null, null,
        null, null, null, null,
        null, null, null, null
      ];
      const result = winDetector.checkRows4x4(board);
      expect(result).toEqual([[0, 1, 2]]);
    });
    
    it('should detect overlapping row wins [0,1,2] and [1,2,3]', () => {
      const board: Cell[] = [
        'X', 'X', 'X', 'X',
        null, null, null, null,
        null, null, null, null,
        null, null, null, null
      ];
      const result = winDetector.checkRows4x4(board);
      expect(result).toContain([0, 1, 2]);
      expect(result).toContain([1, 2, 3]);
      expect(result).toHaveLength(2);
    });
  });
  
  describe('4x4 Diagonal Win Detection', () => {
    it('should detect main diagonal win [0,5,10]', () => {
      const board: Cell[] = [
        'O', null, null, null,
        null, 'O', null, null,
        null, null, 'O', null,
        null, null, null, null
      ];
      const result = winDetector.checkDiagonals4x4(board);
      expect(result).toEqual([[0, 5, 10]]);
    });
    
    it('should detect anti-diagonal win [3,6,9]', () => {
      const board: Cell[] = [
        null, null, null, 'X',
        null, null, 'X', null,
        null, 'X', null, null,
        null, null, null, null
      ];
      const result = winDetector.checkDiagonals4x4(board);
      expect(result).toEqual([[3, 6, 9]]);
    });
  });
  
  describe('4x4 Integration with Engine', () => {
    it('should handle board size routing correctly', () => {
      const state4x4 = createGameState4x4(['X', 'X', 'X', null, ...]);
      expect(winDetector.kInRow(state4x4)).toEqual([[0, 1, 2]]);
      
      const state3x3 = createGameState3x3(['X', 'X', 'X', ...]);
      expect(winDetector.kInRow(state3x3)).toEqual([[0, 1, 2]]);
    });
  });
});
```

**Mock Factory Functions for 4x4:**
```typescript
function createGameState4x4(board: Cell[]): GameState {
  return {
    board: board as readonly Cell[],
    currentPlayer: 'X',
    moveHistory: [],
    status: 'playing',
    winner: null,
    winningLine: null,
    config: { boardSize: 4, kInRow: 3, firstPlayer: 'X', mode: 'human-vs-human' },
    startTime: Date.now()
  };
}
```

**Integration Testing:**
- Test kInRow method integration with complete 4x4 GameState objects
- Verify immutability - original state unchanged after detection
- Test integration with existing Engine interface methods
- Validate cross-board size compatibility (3x3 tests still pass)

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-25 | 1.0 | Initial story creation from Epic 2.3 | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
*This section will be populated by the development agent during implementation*

### Debug Log References
*This section will be populated by the development agent during implementation*

### Completion Notes
*This section will be populated by the development agent during implementation*

### File List
*This section will be populated by the development agent during implementation*

## QA Results
*This section will be populated by the QA agent after implementation review*