# Story 2.4: Move Validation and Turn Alternation

## Status
Done

## Story
**As a** developer implementing the tic-tac-toe game engine,
**I want** robust move validation and seamless turn alternation functionality,
**so that** the engine can reject invalid moves, ensure proper game flow, and maintain immutable state consistency throughout the game lifecycle.

## Acceptance Criteria
1: `legalMoves(state)` returns only empty cells; rejects moves to occupied cells.
2: `applyMove(state, move)` alternates players X/O and returns a new immutable state.
3: Applying a move to a terminal state raises a descriptive error.
4: Unit tests verify invalid move rejection, alternation correctness, and immutability.

## Tasks / Subtasks

- [x] **Task 1: Implement Legal Moves Detection** (AC: 1)
  - [x] Create `legalMoves(state: GameState): number[]` method in Engine interface
  - [x] Return array of positions where board cells are null (empty)
  - [x] Handle both 3x3 and 4x4 board sizes dynamically based on GameState config
  - [x] Ensure method works with existing GameState interface and board array
  - [x] Return empty array when game is in terminal state (won/draw)
  - [x] Unit test all board configurations and game states

- [x] **Task 2: Implement Move Application with Player Alternation** (AC: 2)
  - [x] Create `applyMove(state: GameState, move: Move): GameState` method in Engine interface
  - [x] Validate move position is within legal moves before application
  - [x] Apply move to board array at specified position with current player
  - [x] Alternate currentPlayer from X to O or O to X after move application
  - [x] Add move to moveHistory array with player, position, and timestamp
  - [x] Return completely new immutable GameState object (never mutate input)
  - [x] Update game status using existing terminal detection logic

- [x] **Task 3: Terminal State Move Validation** (AC: 3)
  - [x] Add validation to prevent moves when game status is 'won' or 'draw'
  - [x] Throw descriptive Error with clear message when attempting invalid moves
  - [x] Include current game status and attempted move position in error messages
  - [x] Ensure error handling integrates with existing Engine interface patterns
  - [x] Unit test error conditions and error message accuracy

- [x] **Task 4: Immutability and State Consistency** (AC: 2, 4)
  - [x] Ensure all state transitions create new objects without mutating originals
  - [x] Verify board array, moveHistory, and all nested objects are immutable
  - [x] Update startTime/endTime appropriately during state transitions
  - [x] Maintain config object consistency across state transitions
  - [x] Integration tests verify original state objects remain unchanged
  - [x] Performance tests ensure efficient object creation without memory leaks

- [x] **Task 5: Cross-Board Size Compatibility** (AC: 1, 2)
  - [x] Ensure legalMoves works correctly for both 3x3 (9 positions) and 4x4 (16 positions)
  - [x] Validate applyMove handles board size differences in position bounds
  - [x] Integration tests with various board configurations and game progressions
  - [x] Ensure move validation uses config.boardSize for position bounds checking
  - [x] Test edge cases with different board sizes and game states

- [x] **Task 6: Comprehensive Unit Test Suite** (AC: 4)
  - [x] Test legalMoves with empty, partial, and full boards for both sizes
  - [x] Test applyMove with valid moves, invalid positions, and occupied cells
  - [x] Test player alternation correctness through multiple move sequences
  - [x] Test immutability by verifying original state objects are unchanged
  - [x] Test terminal state move rejection with descriptive error messages
  - [x] Test move history tracking and timestamp accuracy
  - [x] Achieve 100% coverage on all move validation and application methods

## Dev Notes

### Previous Story Insights
Story 2.3 successfully implemented comprehensive k-in-row detection for 4x4 boards with complete backward compatibility. The engine now supports both 3x3 and 4x4 board sizes with efficient win detection, draw logic, and modular architecture. Key established patterns include: immutable state objects, board size routing based on GameState.config.boardSize, comprehensive unit testing with mock factories, and performance optimization techniques.

[Source: docs/stories/2.3.k-in-row-logic-4x4.md]

### Game Engine Architecture Context
[Source: docs/architecture/ADR-002-project-structure.md#game-engine-as-separate-library]

**Framework Independence Requirements:**
- Engine methods must be pure functions with no side effects
- All methods should be deterministic for given inputs
- No dependencies on UI frameworks or external libraries
- State objects must be immutable - methods return new state instances
- Clear separation between game rules and UI presentation logic

**Library Layer Structure:**
- `libs/engine/` contains all game logic, rules, and state management
- Engine interfaces define contracts for game operations
- Public API barrel exports maintain stable interface boundaries
- Unit tests assert interface contracts and immutability patterns

### Move Validation and State Management Requirements
[Source: docs/prd/epic-2-core-engine-perfect-computer-opponent.md]

**Move Validation Specifications:**
- `legalMoves(state)` returns only empty cells; rejects occupied cells
- Move application validates position bounds and availability
- Terminal state detection prevents further moves when game is won/draw
- Error handling provides descriptive messages for invalid operations

**Player Alternation Requirements:**
- `applyMove(state, move)` alternates players X/O automatically
- State transitions maintain immutability with new object creation
- Move history tracking includes player, position, and timestamp
- Game status updates reflect current state after move application

### Type System Integration
[Source: libs/shared/src/lib/types/ from Story 2.1]

**Available Types for Move Operations:**
```typescript
export type Player = 'X' | 'O';

export interface Move {
  readonly player: Player;
  readonly position: number;
  readonly timestamp: number;
}

export interface GameState {
  readonly board: readonly Cell[];
  readonly currentPlayer: Player;
  readonly moveHistory: readonly Move[];
  readonly status: 'playing' | 'won' | 'draw';
  readonly winner: Player | null;
  readonly winningLine: readonly number[] | null;
  readonly config: GameConfig;
  readonly startTime: number;
  readonly endTime?: number;
}

export interface GameConfig {
  readonly boardSize: BoardSize;
  readonly kInRow: number;
  readonly firstPlayer: Player;
  readonly mode: GameMode;
}
```

**Engine Interface Contracts:**
```typescript
export interface Engine {
  legalMoves(state: GameState): number[];
  applyMove(state: GameState, move: Move): GameState;
  isTerminal(state: GameState): boolean;
  winner(state: GameState): Player | null;
  kInRow(state: GameState): number[][];
}
```

### Implementation Approach
[Source: docs/ui-architecture/frontend-developer-standards.md#enterprise-complexity]

**Method Structure Guidelines:**
- Maximum method length: 20 lines per enterprise standards
- Each method should have single, clear responsibility
- Extract complex logic into smaller focused functions
- Use descriptive method names explaining purpose

**Immutability Patterns:**
```typescript
// Correct: Create new state object
const newState: GameState = {
  ...state,
  board: [...state.board],
  moveHistory: [...state.moveHistory, move],
  currentPlayer: alternatePlayer(state.currentPlayer),
  // ... other properties
};

// Incorrect: Mutate existing state
state.board[position] = player; // DON'T DO THIS
state.moveHistory.push(move); // DON'T DO THIS
```

### File Locations and Structure
[Source: docs/architecture/ADR-002-project-structure.md#library-layer]

**Implementation Files (extend these):**
- `libs/engine/src/lib/implementations/tic-tac-toe-engine.ts` - Add legalMoves and applyMove methods
- `libs/engine/src/lib/interfaces/engine.interface.ts` - Update interface with new methods
- `libs/engine/src/lib/implementations/index.ts` - Update barrel exports (if needed)

**Test Files (extend these):**
- `libs/engine/src/lib/implementations/tic-tac-toe-engine.spec.ts` - Add move validation and application tests
- `libs/engine/src/lib/interfaces/engine.interface.spec.ts` - Add interface contract tests

### Error Handling Specifications
[Source: docs/prd/epic-2-core-engine-perfect-computer-opponent.md Story 2.4 AC 3]

**GameError Implementation:**
```typescript
export class GameError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly context?: Record<string, any>
  ) {
    super(message);
    this.name = 'GameError';
  }
}

// Terminal state error example
throw new GameError(
  `Cannot apply move to terminal game. Game status: ${state.status}, Winner: ${state.winner}`,
  'TERMINAL_STATE_MOVE',
  { position, currentStatus: state.status, winner: state.winner }
);
```

### Move Validation Algorithm Specifications

**Legal Moves Detection for Both Board Sizes:**
```typescript
legalMoves(state: GameState): number[] {
  // Return empty array for terminal states
  if (this.isTerminal(state)) {
    return [];
  }
  
  const legalPositions: number[] = [];
  const boardSize = state.config.boardSize;
  const totalCells = boardSize * boardSize;
  
  for (let position = 0; position < totalCells; position++) {
    if (state.board[position] === null) {
      legalPositions.push(position);
    }
  }
  
  return legalPositions;
}
```

**Move Application with Validation and Alternation:**
```typescript
applyMove(state: GameState, move: Move): GameState {
  // Validate terminal state
  if (this.isTerminal(state)) {
    throw new GameError(
      `Cannot apply move to terminal game. Status: ${state.status}`,
      'TERMINAL_STATE_MOVE',
      { move, status: state.status }
    );
  }
  
  // Validate legal move
  const legalMoves = this.legalMoves(state);
  if (!legalMoves.includes(move.position)) {
    throw new GameError(
      `Invalid move position: ${move.position}. Legal moves: [${legalMoves.join(', ')}]`,
      'INVALID_MOVE_POSITION',
      { move, legalMoves }
    );
  }
  
  // Apply move to new board
  const newBoard = [...state.board];
  newBoard[move.position] = move.player;
  
  // Create new state with move applied
  const newState: GameState = {
    ...state,
    board: newBoard,
    currentPlayer: this.alternatePlayer(state.currentPlayer),
    moveHistory: [...state.moveHistory, move],
    // Update status based on new board state
    status: this.calculateGameStatus(newBoard, state.config),
    winner: this.determineWinner(newBoard, state.config),
    winningLine: this.getWinningLine(newBoard, state.config),
    endTime: this.isTerminalState(newBoard, state.config) ? Date.now() : undefined
  };
  
  return newState;
}

private alternatePlayer(currentPlayer: Player): Player {
  return currentPlayer === 'X' ? 'O' : 'X';
}
```

### Board Size Configuration and Bounds
[Source: Story 2.1 Engine Types and Interfaces, Story 2.3 4x4 Logic]

**Supported Board Configurations:**
- 3x3 Board: 9 positions (indices 0-8), k=3
- 4x4 Board: 16 positions (indices 0-15), k=3
- BoardSize determined by `state.config.boardSize`
- Position validation: `0 <= position < boardSize * boardSize`

**Position Mapping Examples:**
```
3x3 Board:          4x4 Board:
0 1 2               0  1  2  3
3 4 5               4  5  6  7
6 7 8               8  9 10 11
                   12 13 14 15
```

### State Transition Logic
[Source: docs/architecture/ADR-002-project-structure.md#immutability-patterns]

**Immutable State Creation Pattern:**
```typescript
// Complete state transition with all fields
const newState: GameState = {
  board: this.createNewBoard(state.board, move),
  currentPlayer: this.alternatePlayer(state.currentPlayer),
  moveHistory: this.addMoveToHistory(state.moveHistory, move),
  status: this.determineGameStatus(newBoard),
  winner: this.determineWinner(newBoard),
  winningLine: this.getWinningLine(newBoard),
  config: state.config, // Config remains unchanged
  startTime: state.startTime, // Start time preserved
  endTime: this.calculateEndTime(newBoard) // Set when game ends
};
```

**Helper Method Specifications:**
```typescript
private createNewBoard(board: readonly Cell[], move: Move): readonly Cell[] {
  const newBoard = [...board];
  newBoard[move.position] = move.player;
  return newBoard;
}

private addMoveToHistory(history: readonly Move[], move: Move): readonly Move[] {
  return [...history, { ...move, timestamp: Date.now() }];
}

private determineGameStatus(board: readonly Cell[]): GameStatus {
  if (this.hasWinner(board)) return 'won';
  if (this.isDraw(board)) return 'draw';
  return 'playing';
}
```

### Integration with Existing Engine Methods
[Source: libs/engine/src/lib/implementations/ from Stories 2.1-2.3]

**Method Integration Strategy:**
- `legalMoves()` uses existing `isTerminal()` for terminal state checking
- `applyMove()` integrates with existing `kInRow()` for win detection
- Move validation leverages existing board size routing patterns
- State transitions use existing immutability patterns from previous stories

**Dependency Integration:**
```typescript
applyMove(state: GameState, move: Move): GameState {
  // Use existing terminal detection
  if (this.isTerminal(state)) {
    throw new GameError('Cannot move in terminal state', 'TERMINAL_MOVE');
  }
  
  // Apply move and create new state
  const newBoard = this.applyMoveToBoard(state.board, move);
  
  // Use existing win detection
  const winningLines = this.kInRow({ ...state, board: newBoard });
  const hasWin = winningLines.length > 0;
  
  // Use existing draw detection
  const isDraw = !hasWin && this.isDraw({ ...state, board: newBoard });
  
  return this.createNewGameState(state, newBoard, move, hasWin, isDraw, winningLines);
}
```

### Performance Optimization Guidelines
[Source: docs/ui-architecture/frontend-developer-standards.md#performance-caching]

**Memory Efficiency for Move Operations:**
- Use spread operators for shallow copying arrays and objects
- Avoid creating unnecessary intermediate objects
- Cache calculated values when possible (board size, total cells)
- Pre-validate inputs to avoid expensive operations on invalid data

**Algorithm Optimization:**
- Legal moves detection: Single pass through board array
- Move validation: Early exit on terminal state or invalid position
- State creation: Minimal object creation with targeted updates
- Error handling: Lazy evaluation of error context information

### Integration with Existing Engine Interface  
[Source: libs/engine/src/lib/interfaces/engine.interface.ts from Story 2.1]

**Updated Engine Interface:**
```typescript
export interface Engine {
  // Existing methods (from previous stories)
  initialState(config: GameConfig): GameState;
  kInRow(state: GameState): number[][];
  isTerminal(state: GameState): boolean;
  winner(state: GameState): Player | null;
  
  // New methods (this story)
  legalMoves(state: GameState): number[];
  applyMove(state: GameState, move: Move): GameState;
}
```

**Implementation Integration Strategy:**
- Add new methods to existing `TicTacToeEngine` class
- Maintain full backward compatibility with existing functionality
- Integrate with established patterns for board size detection
- Use existing helper methods and utilities where applicable

### Error Handling and Edge Cases

**Input Validation Requirements:**
- Verify GameState has valid board array matching config.boardSize
- Validate Move object has required properties (player, position, timestamp)
- Check move.player matches state.currentPlayer
- Ensure position is within valid bounds for board size

**Error Scenarios to Handle:**
- Move attempted on terminal game (won/draw status)
- Move position outside board bounds (< 0 or >= boardSize²)
- Move to occupied cell (board[position] !== null)
- Invalid player in move (not X or O)
- Mismatched player (move.player !== state.currentPlayer)
- Invalid game state structure

**Error Message Examples:**
```typescript
// Terminal state error
"Cannot apply move to terminal game. Game status: won, Winner: X"

// Invalid position error  
"Invalid move position: 9. Valid range: 0-8 for 3x3 board"

// Occupied cell error
"Cannot move to occupied cell at position 4. Cell contains: O"

// Player mismatch error
"Move player X does not match current player O"
```

### Testing

### Unit Testing Strategy
[Source: docs/ui-architecture/testing-requirements.md#unit-testing]

**Test Coverage Requirements:**
- 100% coverage on legalMoves and applyMove methods
- All error conditions tested with appropriate error messages
- Immutability verification through object reference checking
- Board size compatibility tested for both 3x3 and 4x4
- Integration tests with existing engine methods (kInRow, isTerminal)

**Test Categories:**

1. **Legal Moves Detection Tests:**
   - Empty board: all positions legal
   - Partial board: only empty positions legal
   - Full board: no legal moves
   - Terminal state: no legal moves (empty array)
   - Both 3x3 and 4x4 board sizes

2. **Move Application Tests:**
   - Valid moves: state updated correctly
   - Player alternation: X→O, O→X
   - Move history: moves added with timestamps
   - Board updates: correct position filled
   - Status updates: playing→won/draw when appropriate

3. **Terminal State Protection Tests:**
   - Won game: moves rejected with GameError
   - Draw game: moves rejected with GameError
   - Error messages contain current status and context

4. **Immutability Tests:**
   - Original state unchanged after applyMove
   - Board array reference differs in new state
   - Move history array reference differs in new state
   - Nested objects properly copied

5. **Cross-Board Size Tests:**
   - 3x3 board: positions 0-8 validation
   - 4x4 board: positions 0-15 validation
   - Board size routing correctness
   - Move validation adapts to board size

6. **Error Handling Tests:**
   - Invalid positions: GameError with descriptive message
   - Occupied cells: GameError with cell state info
   - Terminal states: GameError with game status info
   - Error context includes relevant debugging information

**Test Implementation Patterns:**
```typescript
describe('Move Validation and Application', () => {
  let engine: TicTacToeEngine;
  
  beforeEach(() => {
    engine = new TicTacToeEngine();
  });
  
  describe('legalMoves', () => {
    it('should return all positions for empty 3x3 board', () => {
      const state = createEmptyGameState3x3();
      const legalMoves = engine.legalMoves(state);
      expect(legalMoves).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8]);
    });
    
    it('should return empty array for terminal state', () => {
      const state = createWonGameState('X');
      const legalMoves = engine.legalMoves(state);
      expect(legalMoves).toEqual([]);
    });
    
    it('should exclude occupied positions', () => {
      const state = createGameStateWithMoves([
        { player: 'X', position: 0, timestamp: Date.now() },
        { player: 'O', position: 4, timestamp: Date.now() }
      ]);
      const legalMoves = engine.legalMoves(state);
      expect(legalMoves).toEqual([1, 2, 3, 5, 6, 7, 8]);
    });
  });
  
  describe('applyMove', () => {
    it('should update board with move', () => {
      const state = createEmptyGameState3x3();
      const move: Move = { player: 'X', position: 0, timestamp: Date.now() };
      
      const newState = engine.applyMove(state, move);
      
      expect(newState.board[0]).toBe('X');
      expect(state.board[0]).toBeNull(); // Original unchanged
    });
    
    it('should alternate players', () => {
      const state = createGameState({ currentPlayer: 'X' });
      const move: Move = { player: 'X', position: 0, timestamp: Date.now() };
      
      const newState = engine.applyMove(state, move);
      
      expect(newState.currentPlayer).toBe('O');
    });
    
    it('should add move to history', () => {
      const state = createEmptyGameState3x3();
      const move: Move = { player: 'X', position: 0, timestamp: Date.now() };
      
      const newState = engine.applyMove(state, move);
      
      expect(newState.moveHistory).toHaveLength(1);
      expect(newState.moveHistory[0]).toEqual(move);
      expect(state.moveHistory).toHaveLength(0); // Original unchanged
    });
    
    it('should throw error for terminal state', () => {
      const state = createWonGameState('X');
      const move: Move = { player: 'O', position: 1, timestamp: Date.now() };
      
      expect(() => engine.applyMove(state, move)).toThrow(GameError);
      expect(() => engine.applyMove(state, move)).toThrow(/terminal game/);
    });
    
    it('should throw error for invalid position', () => {
      const state = createEmptyGameState3x3();
      const move: Move = { player: 'X', position: 9, timestamp: Date.now() };
      
      expect(() => engine.applyMove(state, move)).toThrow(GameError);
      expect(() => engine.applyMove(state, move)).toThrow(/Invalid move position/);
    });
  });
  
  describe('4x4 Board Compatibility', () => {
    it('should handle 4x4 legal moves correctly', () => {
      const state = createEmptyGameState4x4();
      const legalMoves = engine.legalMoves(state);
      expect(legalMoves).toEqual([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]);
    });
    
    it('should validate 4x4 move positions', () => {
      const state = createEmptyGameState4x4();
      const move: Move = { player: 'X', position: 16, timestamp: Date.now() };
      
      expect(() => engine.applyMove(state, move)).toThrow(GameError);
    });
  });
});
```

**Mock Factory Functions:**
```typescript
function createEmptyGameState3x3(): GameState {
  return {
    board: new Array(9).fill(null),
    currentPlayer: 'X',
    moveHistory: [],
    status: 'playing',
    winner: null,
    winningLine: null,
    config: { boardSize: 3, kInRow: 3, firstPlayer: 'X', mode: 'human-vs-human' },
    startTime: Date.now()
  };
}

function createEmptyGameState4x4(): GameState {
  return {
    board: new Array(16).fill(null),
    currentPlayer: 'X',
    moveHistory: [],
    status: 'playing',
    winner: null,
    winningLine: null,
    config: { boardSize: 4, kInRow: 3, firstPlayer: 'X', mode: 'human-vs-human' },
    startTime: Date.now()
  };
}

function createWonGameState(winner: Player): GameState {
  const board = new Array(9).fill(null);
  board[0] = winner;
  board[1] = winner;
  board[2] = winner;
  
  return {
    board,
    currentPlayer: winner === 'X' ? 'O' : 'X',
    moveHistory: [
      { player: winner, position: 0, timestamp: Date.now() - 300 },
      { player: winner === 'X' ? 'O' : 'X', position: 3, timestamp: Date.now() - 200 },
      { player: winner, position: 1, timestamp: Date.now() - 100 },
      { player: winner === 'X' ? 'O' : 'X', position: 4, timestamp: Date.now() - 50 },
      { player: winner, position: 2, timestamp: Date.now() }
    ],
    status: 'won',
    winner,
    winningLine: [0, 1, 2],
    config: { boardSize: 3, kInRow: 3, firstPlayer: 'X', mode: 'human-vs-human' },
    startTime: Date.now() - 1000,
    endTime: Date.now()
  };
}
```

**Integration Testing:**
- Test move application with win detection integration
- Verify state transitions trigger appropriate status updates
- Test move validation with existing terminal state detection
- Validate cross-method compatibility and consistency

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-25 | 1.0 | Initial story creation from Epic 2.4 | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
GitHub Copilot (Claude-3.5-Sonnet) - Full Stack Developer Agent

### Debug Log References
- Engine implementation was already complete from previous stories
- All 238 engine tests passing successfully
- GameError class created in shared library for enhanced error handling
- Comprehensive validation and immutability patterns verified

### Completion Notes List
- ✅ **Legal Moves Detection**: `legalMoves()` method already implemented and fully tested for both 3x3 and 4x4 boards
- ✅ **Move Application**: `applyMove()` method already implemented with proper player alternation and state transitions
- ✅ **Terminal State Validation**: Comprehensive error handling prevents moves on won/draw games
- ✅ **Immutability**: All state transitions create new objects, original states remain unchanged
- ✅ **Cross-Board Compatibility**: Full support for both 3x3 and 4x4 board sizes with dynamic position validation
- ✅ **Error Handling**: Descriptive error messages with game status and position context
- ✅ **Test Coverage**: 238 comprehensive tests covering all acceptance criteria and edge cases
- ✅ **GameError Infrastructure**: Added GameError class to shared library for enhanced error context

### File List
**Modified Files:**
- `libs/shared/src/lib/types/error-types.ts` - Created GameError class for enhanced error handling
- `libs/shared/src/lib/types/index.ts` - Added export for GameError class
- `libs/engine/src/lib/implementations/tic-tac-toe-engine.ts` - Enhanced error messages with detailed context
- `libs/engine/src/lib/implementations/tic-tac-toe-engine.spec.ts` - Updated tests for enhanced error handling

**Verified Existing Implementation:**
- `libs/engine/src/lib/interfaces/engine.interface.ts` - Complete interface with legalMoves and applyMove methods
- `libs/engine/src/lib/implementations/tic-tac-toe-engine.ts` - Full implementation of all required functionality
- All test files covering comprehensive move validation and state management scenarios

## QA Results
*This section will be populated by the QA agent after implementation review*