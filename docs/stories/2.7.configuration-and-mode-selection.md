# Story 2.7: Configuration and Mode Selection

## Status
Reviewed

## Story
**As a** developer implementing the tic-tac-toe game engine,
**I want** comprehensive game configuration support with factory patterns and mode selection,
**so that** the engine can properly initialize different game modes (3x3, 4x4) with configurable settings that are accessible throughout the game lifecycle for UI display and testing.

## Acceptance Criteria
1: `GameConfig` supports board size (3x3 or 4x4), k value (3 for both), and initial player.
2: Engine exposes a factory to create an `Engine` with a given `GameConfig`; config is surfaced in `GameState` for UI/tests.
3: Unit tests verify both modes initialize correctly and propagate config through state transitions.

## Tasks / Subtasks

- [ ] **Task 1: Validate GameConfig Type Completeness** (AC: 1)
  - [ ] Review existing `GameConfig` interface in `libs/shared/src/lib/types/game-state-types.ts`
  - [ ] Verify support for board size configuration (3x3 or 4x4)
  - [ ] Verify k value configuration (3 for both board sizes)
  - [ ] Verify initial player configuration
  - [ ] Add any missing configuration properties if needed
  - [ ] Update JSDoc documentation for GameConfig completeness

- [ ] **Task 2: Create Engine Factory Pattern** (AC: 2)
  - [ ] Create `EngineFactory` class in `libs/engine/src/lib/factories/engine-factory.ts`
  - [ ] Implement `createEngine(config: GameConfig): Engine` factory method
  - [ ] Ensure factory validates configuration before creating engine instance
  - [ ] Implement factory method to create pre-configured engine instances
  - [ ] Export factory through engine public API barrel
  - [ ] Add comprehensive JSDoc documentation for factory usage

- [ ] **Task 3: Configuration Propagation and Access** (AC: 2)
  - [ ] Verify `initialState(config)` method stores config in GameState
  - [ ] Ensure config is preserved through all state transitions in `applyMove`
  - [ ] Validate config accessibility in GameState for UI consumption
  - [ ] Create helper methods for config access if needed (board dimensions, win condition)
  - [ ] Ensure config immutability throughout game lifecycle

- [ ] **Task 4: Mode-Specific Initialization Testing** (AC: 3)
  - [ ] Create unit tests for 3x3 board configuration initialization
  - [ ] Create unit tests for 4x4 board configuration initialization
  - [ ] Test different initial player configurations ('X', 'O')
  - [ ] Test different game modes (human-vs-human, human-vs-computer)
  - [ ] Verify config propagation through multiple state transitions
  - [ ] Test factory creation with various configuration combinations

- [ ] **Task 5: Configuration Validation and Error Handling** (AC: 1, 2)
  - [ ] Add configuration validation in EngineFactory
  - [ ] Validate board size is 3 or 4
  - [ ] Validate k value is 3 for both board sizes
  - [ ] Validate initial player is 'X' or 'O'
  - [ ] Validate game mode is supported value
  - [ ] Add comprehensive error messages for invalid configurations
  - [ ] Create unit tests for configuration validation edge cases

- [ ] **Task 6: Factory Integration and Documentation** (AC: 2)
  - [ ] Update `libs/engine/src/index.ts` to export EngineFactory
  - [ ] Create usage examples in factory JSDoc documentation
  - [ ] Add factory to existing README documentation if present
  - [ ] Create integration examples showing factory usage patterns
  - [ ] Verify factory works with existing engine interface contracts

## Dev Notes

### Previous Story Insights
Story 2.5 successfully completed terminal state detection and result determination with comprehensive terminal state information, cross-board size support, and integration with existing engine methods. All 238 engine tests are passing. The engine now has complete game state management including terminal detection, winner determination, and complete game lifecycle handling. Key established patterns include immutable state transitions, comprehensive error handling, and robust integration between engine components.

[Source: docs/stories/2.5.terminal-state-detection-and-result.md]

### Existing Type System Foundation
[Source: libs/shared/src/lib/types/game-state-types.ts]

**GameConfig Interface Already Defined:**
```typescript
export interface GameConfig {
  /** The size of the game board (3 for 3x3, 4 for 4x4) */
  readonly boardSize: BoardSize;
  
  /** Number of consecutive marks needed to win (always 3 for both board sizes) */
  readonly kInRow: number;
  
  /** Which player goes first */
  readonly firstPlayer: Player;
  
  /** The type of game being played */
  readonly mode: GameMode;
}
```

**GameState Config Integration:**
```typescript
export interface GameState {
  // ... other properties
  /** The configuration used to create this game */
  readonly config: GameConfig;
  // ... other properties
}
```

**Available Supporting Types:**
- `BoardSize` type (3 | 4) for board size validation
- `Player` type ('X' | 'O') for initial player validation  
- `GameMode` type for mode selection validation

### Current Engine Implementation Context
[Source: libs/engine/src/lib/implementations/tic-tac-toe-engine.ts]

**Existing initialState Implementation:**
```typescript
initialState(config: GameConfig): GameState {
  const boardSize = config.boardSize * config.boardSize;
  const board: Cell[] = new Array(boardSize).fill(null);
  
  return {
    board: board as readonly Cell[],
    currentPlayer: config.firstPlayer,
    moveHistory: [],
    status: 'playing',
    winner: null,
    winningLine: null,
    config,  // Config already stored in GameState
    startTime: Date.now()
  };
}
```

**Config Propagation in applyMove:**
```typescript
return {
  board: newBoard as readonly Cell[],
  currentPlayer: nextPlayer,
  moveHistory: [...state.moveHistory, move] as readonly Move[],
  status,
  winner,
  winningLine: winningLine as readonly number[] | null,
  config: state.config,  // Config preserved through transitions
  startTime: state.startTime,
  endTime: status !== 'playing' ? Date.now() : undefined
};
```

### Factory Pattern Requirements
[Source: docs/prd/epic-2-core-engine-perfect-computer-opponent.md Story 2.7 AC 2]

**Factory Design Pattern:**
```typescript
// Recommended factory implementation structure
export class EngineFactory {
  /**
   * Creates a new Engine instance with the given configuration.
   * Validates configuration before creating engine.
   * 
   * @param config - Game configuration for engine initialization
   * @returns Configured engine instance ready for game creation
   * @throws {Error} If configuration is invalid
   */
  static createEngine(config: GameConfig): Engine {
    this.validateConfig(config);
    return new TicTacToeEngine();
  }
  
  /**
   * Creates a pre-configured 3x3 engine with default settings.
   */
  static create3x3Engine(firstPlayer: Player = 'X'): Engine {
    const config: GameConfig = {
      boardSize: 3,
      kInRow: 3,
      firstPlayer,
      mode: 'human-vs-human'
    };
    return this.createEngine(config);
  }
  
  /**
   * Creates a pre-configured 4x4 engine with default settings.
   */
  static create4x4Engine(firstPlayer: Player = 'X'): Engine {
    const config: GameConfig = {
      boardSize: 4,
      kInRow: 3,
      firstPlayer,
      mode: 'human-vs-human'
    };
    return this.createEngine(config);
  }
  
  private static validateConfig(config: GameConfig): void {
    // Validation logic for configuration parameters
  }
}
```

### Configuration Validation Requirements
[Source: docs/prd/epic-2-core-engine-perfect-computer-opponent.md Story 2.7 AC 1]

**Required Validation Rules:**
- Board size must be 3 or 4 only
- k value must be 3 for both board sizes (AC requirement)
- Initial player must be 'X' or 'O'
- Game mode must be valid GameMode value
- All configuration properties must be present and well-formed

**Validation Implementation Pattern:**
```typescript
private static validateConfig(config: GameConfig): void {
  if (!config) {
    throw new Error('GameConfig is required');
  }
  
  if (config.boardSize !== 3 && config.boardSize !== 4) {
    throw new Error(`Invalid board size: ${config.boardSize}. Must be 3 or 4`);
  }
  
  if (config.kInRow !== 3) {
    throw new Error(`Invalid k value: ${config.kInRow}. Must be 3 for both board sizes`);
  }
  
  if (config.firstPlayer !== 'X' && config.firstPlayer !== 'O') {
    throw new Error(`Invalid first player: ${config.firstPlayer}. Must be 'X' or 'O'`);
  }
  
  // Additional mode validation based on GameMode type definition
}
```

### File Locations and Structure
[Source: docs/architecture/ADR-002-project-structure.md#library-layer]

**New Implementation Files:**
- `libs/engine/src/lib/factories/engine-factory.ts` - EngineFactory class implementation
- `libs/engine/src/lib/factories/index.ts` - Factory barrel exports

**Update Existing Files:**
- `libs/engine/src/index.ts` - Add EngineFactory to public API exports
- `libs/engine/src/lib/implementations/index.ts` - Verify TicTacToeEngine export

**New Test Files:**
- `libs/engine/src/lib/factories/engine-factory.spec.ts` - Factory unit tests
- Integration tests in existing engine test suites

### Mode-Specific Initialization Patterns
[Source: docs/ui-architecture/frontend-developer-standards.md#game-engine-integration]

**3x3 Mode Initialization:**
```typescript
// 3x3 board: 9 cells (indices 0-8), k=3, typical tic-tac-toe
const config3x3: GameConfig = {
  boardSize: 3,
  kInRow: 3,
  firstPlayer: 'X',
  mode: 'human-vs-human'
};
const engine3x3 = EngineFactory.createEngine(config3x3);
const gameState3x3 = engine3x3.initialState(config3x3);
```

**4x4 Mode Initialization:**
```typescript
// 4x4 board: 16 cells (indices 0-15), k=3, still 3-in-a-row to win
const config4x4: GameConfig = {
  boardSize: 4,
  kInRow: 3,
  firstPlayer: 'O',
  mode: 'human-vs-computer'
};
const engine4x4 = EngineFactory.createEngine(config4x4);
const gameState4x4 = engine4x4.initialState(config4x4);
```

### Integration with Existing Engine Architecture
[Source: libs/engine/src/lib/interfaces/engine.interface.ts]

**Engine Interface Compatibility:**
- Factory creates instances that implement existing Engine interface
- All engine methods (initialState, legalMoves, applyMove, etc.) work with factory-created engines
- Configuration is passed through existing initialState(config) method
- Factory provides convenience layer without breaking existing patterns

**Configuration Access Patterns:**
```typescript
// Config accessible through GameState for UI and testing
const gameState = engine.initialState(config);
const boardDimensions = gameState.config.boardSize; // 3 or 4
const winCondition = gameState.config.kInRow; // Always 3
const startingPlayer = gameState.config.firstPlayer; // 'X' or 'O'
const gameMode = gameState.config.mode; // GameMode value

// Config persists through all state transitions
const move: Move = { player: 'X', position: 4, timestamp: Date.now() };
const newState = engine.applyMove(gameState, move);
console.log(newState.config === gameState.config); // true (same reference)
```

### Testing Strategy Requirements
[Source: docs/ui-architecture/testing-requirements.md#unit-testing]

**Configuration Testing Categories:**

1. **Factory Creation Tests:**
   - Valid configuration creates engine successfully
   - Invalid configurations throw appropriate errors
   - Pre-configured factory methods work correctly
   - Factory validation covers all edge cases

2. **Configuration Propagation Tests:**
   - Config stored correctly in initial GameState
   - Config preserved through state transitions
   - Config remains immutable throughout game lifecycle
   - Config accessible for UI and testing purposes

3. **Mode-Specific Initialization Tests:**
   - 3x3 mode creates 9-cell board correctly
   - 4x4 mode creates 16-cell board correctly
   - Different initial players work correctly
   - Different game modes initialize properly

4. **Integration Tests:**
   - Factory-created engines work with all existing engine methods
   - Configuration works end-to-end through complete game
   - Multiple game instances with different configs work independently

**Test Implementation Patterns:**
```typescript
describe('EngineFactory', () => {
  describe('createEngine', () => {
    it('should create engine with valid 3x3 configuration', () => {
      const config: GameConfig = {
        boardSize: 3,
        kInRow: 3,
        firstPlayer: 'X',
        mode: 'human-vs-human'
      };
      
      const engine = EngineFactory.createEngine(config);
      expect(engine).toBeInstanceOf(TicTacToeEngine);
      
      const gameState = engine.initialState(config);
      expect(gameState.config).toEqual(config);
      expect(gameState.board.length).toBe(9);
    });
    
    it('should create engine with valid 4x4 configuration', () => {
      const config: GameConfig = {
        boardSize: 4,
        kInRow: 3,
        firstPlayer: 'O',
        mode: 'human-vs-computer'
      };
      
      const engine = EngineFactory.createEngine(config);
      const gameState = engine.initialState(config);
      expect(gameState.config).toEqual(config);
      expect(gameState.board.length).toBe(16);
      expect(gameState.currentPlayer).toBe('O');
    });
    
    it('should throw error for invalid board size', () => {
      const invalidConfig = {
        boardSize: 5, // Invalid
        kInRow: 3,
        firstPlayer: 'X',
        mode: 'human-vs-human'
      } as GameConfig;
      
      expect(() => EngineFactory.createEngine(invalidConfig))
        .toThrow('Invalid board size: 5. Must be 3 or 4');
    });
    
    it('should throw error for invalid k value', () => {
      const invalidConfig: GameConfig = {
        boardSize: 3,
        kInRow: 4, // Invalid for 3x3
        firstPlayer: 'X',
        mode: 'human-vs-human'
      };
      
      expect(() => EngineFactory.createEngine(invalidConfig))
        .toThrow('Invalid k value: 4. Must be 3 for both board sizes');
    });
  });
  
  describe('pre-configured factories', () => {
    it('should create 3x3 engine with defaults', () => {
      const engine = EngineFactory.create3x3Engine();
      const gameState = engine.initialState(engine.getDefaultConfig());
      
      expect(gameState.config.boardSize).toBe(3);
      expect(gameState.config.kInRow).toBe(3);
      expect(gameState.config.firstPlayer).toBe('X');
    });
    
    it('should create 4x4 engine with custom first player', () => {
      const engine = EngineFactory.create4x4Engine('O');
      const gameState = engine.initialState(engine.getDefaultConfig());
      
      expect(gameState.config.boardSize).toBe(4);
      expect(gameState.config.firstPlayer).toBe('O');
    });
  });
});

describe('Configuration Propagation', () => {
  let engine: Engine;
  let config: GameConfig;
  
  beforeEach(() => {
    config = {
      boardSize: 3,
      kInRow: 3,
      firstPlayer: 'X',
      mode: 'human-vs-human'
    };
    engine = EngineFactory.createEngine(config);
  });
  
  it('should preserve config through state transitions', () => {
    let gameState = engine.initialState(config);
    expect(gameState.config).toEqual(config);
    
    const move: Move = { player: 'X', position: 0, timestamp: Date.now() };
    gameState = engine.applyMove(gameState, move);
    expect(gameState.config).toEqual(config);
    
    const move2: Move = { player: 'O', position: 1, timestamp: Date.now() };
    gameState = engine.applyMove(gameState, move2);
    expect(gameState.config).toEqual(config);
  });
  
  it('should maintain config immutability', () => {
    const gameState = engine.initialState(config);
    const originalConfig = gameState.config;
    
    const move: Move = { player: 'X', position: 4, timestamp: Date.now() };
    const newState = engine.applyMove(gameState, move);
    
    expect(newState.config).toBe(originalConfig); // Same reference
    expect(Object.isFrozen(newState.config)).toBe(true); // Immutable
  });
});
```

### Testing

### Unit Testing Strategy
[Source: docs/ui-architecture/testing-requirements.md#unit-testing]

**Test Coverage Requirements:**
- 100% coverage on EngineFactory class and methods
- Configuration validation edge cases tested
- Both 3x3 and 4x4 mode initialization tested  
- Config propagation through state transitions verified
- Integration with existing engine interface confirmed

**Test Categories:**

1. **Factory Creation and Validation Tests:**
   - Valid configurations create engines successfully
   - Invalid board sizes rejected with clear error messages
   - Invalid k values rejected with clear error messages
   - Invalid initial players rejected with clear error messages
   - Invalid game modes rejected with clear error messages
   - Null/undefined configuration handling

2. **Pre-configured Factory Method Tests:**
   - Default 3x3 engine creation works correctly
   - Default 4x4 engine creation works correctly
   - Custom initial player options work correctly
   - Default values applied correctly when not specified

3. **Configuration Propagation Tests:**
   - Configuration stored correctly in initial GameState
   - Configuration preserved through move applications
   - Configuration remains immutable throughout game lifecycle
   - Configuration accessible for UI consumption and testing

4. **Mode-Specific Initialization Tests:**
   - 3x3 mode creates correct board size (9 cells)
   - 4x4 mode creates correct board size (16 cells)
   - Different initial players set correctly in GameState
   - Different game modes stored correctly in GameState
   - Board initialization works correctly for both sizes

5. **Integration and Compatibility Tests:**
   - Factory-created engines implement Engine interface correctly
   - All existing engine methods work with factory-created instances
   - Configuration works end-to-end through complete game scenarios
   - Multiple concurrent games with different configs work independently

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-25 | 1.0 | Initial story creation from Epic 2.7 | Bob (Scrum Master) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

## QA Results

*This section will be populated by the QA agent after implementation review*