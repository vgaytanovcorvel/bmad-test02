# Story 2.8: Performance (Simplified)

## Status
Draft

## Story
**As a** developer implementing the tic-tac-toe game engine,
**I want** performance-optimized engine implementation with efficient inner loops and simple timing validation,
**so that** the engine delivers fast move calculations under 10ms while maintaining clean, maintainable code with enforced immutability patterns and proper linting rules.

## Acceptance Criteria
1: Inner loops avoid unnecessary allocations.
2: Simple timing assertion (optional) demonstrates typical move calculation <10ms.
3: Lint rules enforce immutability patterns.

## Tasks / Subtasks

- [ ] **Task 1: Engine Performance Optimization** (AC: 1)
  - [ ] Review current engine implementations for unnecessary allocations in inner loops
  - [ ] Optimize `kInRow` detection algorithms to minimize object creation
  - [ ] Optimize move validation loops to avoid array copying
  - [ ] Optimize terminal state detection to minimize repeated calculations
  - [ ] Ensure board access patterns use efficient indexing
  - [ ] Profile memory allocation patterns in critical paths
  - [ ] Add performance comments to document optimization strategies

- [ ] **Task 2: Timing Validation Implementation** (AC: 2)
  - [ ] Create performance timing utility for move calculation measurement
  - [ ] Add optional timing assertions to critical engine test cases
  - [ ] Implement move calculation timing tests for both 3x3 and 4x4 boards
  - [ ] Create performance benchmark test suite with <10ms target
  - [ ] Add timing tests for computer player move calculation
  - [ ] Document performance expectations in test comments
  - [ ] Include timing tests in CI pipeline (optional assertion)

- [ ] **Task 3: Immutability Lint Rules Configuration** (AC: 3)
  - [ ] Configure ESLint rules to enforce immutability patterns
  - [ ] Add TypeScript strict rules for readonly properties
  - [ ] Configure lint rules to prevent direct state mutation
  - [ ] Add lint rules to enforce functional programming patterns
  - [ ] Configure rules to require const assertions for arrays and objects
  - [ ] Validate existing code passes immutability lint checks
  - [ ] Update project documentation with immutability standards

- [ ] **Task 4: Performance Testing and Validation** (AC: 1, 2)
  - [ ] Create performance test suite measuring algorithm efficiency
  - [ ] Add memory usage monitoring for critical engine operations
  - [ ] Implement automated performance regression detection
  - [ ] Validate performance optimizations don't break existing functionality
  - [ ] Create performance documentation with benchmark results
  - [ ] Add performance validation to existing integration tests

## Dev Notes

### Previous Story Insights
Story 2.7 successfully completed configuration and mode selection with comprehensive factory pattern, validation, and testing. All 264 engine tests are passing with complete configuration propagation and immutability preservation. The engine now has a solid foundation of proper configuration management, factory patterns, and comprehensive validation. Key established patterns include immutable state transitions, comprehensive error handling, and robust integration between engine components.

[Source: docs/stories/2.7.configuration-and-mode-selection.md]

### Performance Requirements and Context
[Source: docs/prd/epic-2-core-engine-perfect-computer-opponent.md Story 2.8]

**Simplified Performance Goals:**
- Inner loops avoid unnecessary allocations (AC 1)
- Simple timing assertion demonstrates typical move calculation <10ms (AC 2) 
- Lint rules enforce immutability patterns (AC 3)

**Performance vs Complexity Balance:**
The simplified performance approach focuses on basic optimizations without over-engineering. The goal is clean, efficient code rather than micro-optimizations that compromise maintainability.

### Current Engine Implementation Analysis
[Source: libs/engine/src/lib/implementations/tic-tac-toe-engine.ts]

**Critical Performance Areas for Optimization:**

1. **K-in-Row Detection Algorithms:**
```typescript
// Current implementation pattern to optimize
kInRow(state: GameState): readonly number[] | null {
  const { board, config } = state;
  const size = config.boardSize;
  const k = config.kInRow;
  
  // Row checking - optimize to avoid array allocations
  for (let row = 0; row < size; row++) {
    // Current pattern creates arrays - optimize this
    const rowCells = Array.from({ length: size }, (_, col) => row * size + col);
    // Optimize to direct indexing without array creation
  }
}
```

2. **Move Validation Loops:**
```typescript
// Current legalMoves implementation to optimize
legalMoves(state: GameState): readonly Move[] {
  // Avoid unnecessary array operations and object creation
  const moves: Move[] = [];
  const { board } = state;
  
  // Optimize this loop to minimize allocations
  for (let i = 0; i < board.length; i++) {
    if (board[i] === null) {
      moves.push({
        player: state.currentPlayer,
        position: i,
        timestamp: Date.now() // Consider optimizing timestamp creation
      });
    }
  }
  
  return moves as readonly Move[];
}
```

3. **Terminal State Detection:**
```typescript
// Current isTerminal implementation to optimize
isTerminal(state: GameState): boolean {
  // Minimize repeated calculations
  const winResult = this.kInRow(state);
  if (winResult !== null) {
    return true;
  }
  
  // Optimize board scan for empty cells
  return this.legalMoves(state).length === 0;
}
```

### Architecture Performance Standards
[Source: docs/ui-architecture/frontend-developer-standards.md]

**Critical Performance Rules:**
- **Performance Caching**: Cache calculated variables; avoid re-evaluation
- **Memory Efficiency**: Use collections appropriately and minimize memory footprint
- **Loop Simplification**: Avoid nested loops; extract to dedicated methods
- **Resource Management**: Ensure proper disposal and cleanup of resources

**Enterprise Performance Guidelines:**
```typescript
// ✅ GOOD: Efficient loop with minimal allocations
private checkRowWin(board: readonly Cell[], size: number, row: number, k: number): number[] | null {
  let count = 0;
  let currentPlayer: Player | null = null;
  const winPositions: number[] = [];
  
  for (let col = 0; col < size; col++) {
    const position = row * size + col;
    const cell = board[position];
    
    if (cell === currentPlayer && cell !== null) {
      count++;
      winPositions.push(position);
      if (count >= k) {
        return winPositions.slice(-k); // Return only winning positions
      }
    } else {
      currentPlayer = cell;
      count = cell !== null ? 1 : 0;
      winPositions.length = 0; // Clear array without allocation
      if (cell !== null) {
        winPositions.push(position);
      }
    }
  }
  
  return null;
}

// ❌ BAD: Inefficient with unnecessary allocations
private checkRowWinBad(board: readonly Cell[], size: number, row: number, k: number): number[] | null {
  const rowCells = Array.from({ length: size }, (_, col) => row * size + col); // Unnecessary array
  const values = rowCells.map(pos => board[pos]); // Another unnecessary array
  
  for (let i = 0; i <= size - k; i++) {
    const slice = values.slice(i, i + k); // More allocations
    if (slice.every(cell => cell !== null && cell === slice[0])) {
      return rowCells.slice(i, i + k); // Even more allocations
    }
  }
  
  return null;
}
```

### Timing Validation Implementation Strategy
[Source: docs/ui-architecture/testing-requirements.md]

**Performance Testing Patterns:**
```typescript
// Performance timing utility for engine operations
export class PerformanceTimer {
  static measureOperation<T>(operation: () => T): { result: T; duration: number } {
    const start = performance.now();
    const result = operation();
    const duration = performance.now() - start;
    return { result, duration };
  }
  
  static assertTiming<T>(
    operation: () => T, 
    maxDurationMs: number, 
    description: string
  ): T {
    const { result, duration } = this.measureOperation(operation);
    
    // Optional assertion - only fails in performance-critical tests
    if (duration > maxDurationMs) {
      console.warn(`Performance warning: ${description} took ${duration.toFixed(2)}ms (target: ${maxDurationMs}ms)`);
    }
    
    return result;
  }
}

// Example usage in tests
describe('Engine Performance', () => {
  it('should calculate moves within 10ms', () => {
    const engine = EngineFactory.create3x3Engine();
    const gameState = engine.initialState(createConfig());
    
    const legalMoves = PerformanceTimer.assertTiming(
      () => engine.legalMoves(gameState),
      10,
      '3x3 legal moves calculation'
    );
    
    expect(legalMoves.length).toBe(9);
  });
  
  it('should detect terminal state within 10ms', () => {
    const engine = EngineFactory.create4x4Engine();
    const gameState = createNearTerminalState(); // Factory function
    
    const isTerminal = PerformanceTimer.assertTiming(
      () => engine.isTerminal(gameState),
      10,
      '4x4 terminal detection'
    );
    
    expect(typeof isTerminal).toBe('boolean');
  });
});
```

### Immutability Lint Rules Configuration
[Source: docs/architecture/ADR-001-tech-stack.md]

**ESLint Immutability Configuration:**
```typescript
// eslint.config.mjs additions for immutability
export default [
  {
    files: ['libs/engine/**/*.ts', 'libs/shared/**/*.ts'],
    rules: {
      // Enforce immutability patterns
      'prefer-const': 'error',
      'no-var': 'error',
      'no-param-reassign': 'error',
      '@typescript-eslint/prefer-readonly': 'error',
      '@typescript-eslint/prefer-readonly-parameter-types': 'warn',
      
      // Prevent direct mutation
      'no-object-mutation/no-mutation': 'error',
      'functional/no-mutating-assign': 'error',
      'functional/no-mutating-methods': 'error',
      'functional/immutable-data': 'error',
      
      // Enforce functional patterns
      'functional/no-let': 'warn',
      'functional/prefer-immutable-types': 'error',
    }
  }
];
```

**TypeScript Strict Configuration for Immutability:**
```json
// tsconfig.json additions for immutability
{
  "compilerOptions": {
    "strict": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true
  },
  "compilerOptions": {
    // Enforce readonly patterns
    "declaration": true,
    "declarationMap": true
  }
}
```

### File Locations and Structure
[Source: docs/architecture/ADR-002-project-structure.md]

**Performance Testing Files:**
- `libs/engine/src/lib/testing/performance-timer.ts` - Performance timing utilities
- `libs/engine/src/lib/testing/performance-timer.spec.ts` - Timer utility tests
- `libs/engine/src/lib/implementations/tic-tac-toe-engine.perf.spec.ts` - Engine performance tests

**Configuration Files to Update:**
- `eslint.config.mjs` - Add immutability rules for engine and shared libraries
- `libs/engine/tsconfig.json` - Enhance strict mode configuration
- `libs/shared/tsconfig.json` - Enhance strict mode configuration

**Engine Implementation Files to Optimize:**
- `libs/engine/src/lib/implementations/tic-tac-toe-engine.ts` - Core engine optimizations
- `libs/engine/src/lib/rules/k-in-row.ts` - K-in-row algorithm optimizations (if extracted)
- `libs/engine/src/lib/validation/move-validator.ts` - Move validation optimizations

### Memory Allocation Optimization Patterns
[Source: docs/ui-architecture/frontend-developer-standards.md]

**Efficient Loop Patterns:**
```typescript
// ✅ OPTIMAL: Direct indexing without allocations
private findWinningLine(board: readonly Cell[], size: number, k: number): number[] | null {
  // Check rows
  for (let row = 0; row < size; row++) {
    for (let col = 0; col <= size - k; col++) {
      const startPos = row * size + col;
      const firstCell = board[startPos];
      
      if (firstCell !== null) {
        let consecutive = 1;
        for (let i = 1; i < k; i++) {
          if (board[startPos + i] !== firstCell) {
            break;
          }
          consecutive++;
        }
        
        if (consecutive === k) {
          // Create result array only when win found
          const winLine = new Array(k);
          for (let i = 0; i < k; i++) {
            winLine[i] = startPos + i;
          }
          return winLine;
        }
      }
    }
  }
  
  return null;
}

// ❌ INEFFICIENT: Multiple array allocations
private findWinningLineBad(board: readonly Cell[], size: number, k: number): number[] | null {
  // Creates unnecessary arrays for each check
  for (let row = 0; row < size; row++) {
    const rowPositions = Array.from({ length: size }, (_, col) => row * size + col);
    for (let col = 0; col <= size - k; col++) {
      const checkPositions = rowPositions.slice(col, col + k);
      const values = checkPositions.map(pos => board[pos]);
      if (values.every(val => val !== null && val === values[0])) {
        return checkPositions;
      }
    }
  }
  return null;
}
```

**Immutable State Management:**
```typescript
// ✅ OPTIMAL: Minimal state copying
applyMove(state: GameState, move: Move): GameState {
  // Validate move first to avoid unnecessary copying
  if (!this.isValidMove(state, move)) {
    throw new Error('Invalid move');
  }
  
  // Create new board with single change
  const newBoard = [...state.board];
  newBoard[move.position] = move.player;
  
  // Calculate new state properties efficiently
  const nextPlayer = move.player === 'X' ? 'O' : 'X';
  const winningLine = this.findWinningLine(newBoard, state.config.boardSize, state.config.kInRow);
  const winner = winningLine ? move.player : null;
  const status = winner ? 'won' : (this.isBoardFull(newBoard) ? 'draw' : 'playing');
  
  // Return new state with minimal object creation
  return {
    ...state, // Spread existing state
    board: newBoard as readonly Cell[],
    currentPlayer: nextPlayer,
    winner,
    winningLine: winningLine as readonly number[] | null,
    status,
    moveHistory: [...state.moveHistory, move] as readonly Move[],
    endTime: status !== 'playing' ? Date.now() : undefined
  };
}
```

### Testing Performance Integration
[Source: docs/ui-architecture/testing-requirements.md]

**Unit Testing for Performance:**
- Individual algorithm performance tests with timing assertions
- Memory allocation profiling tests for critical paths
- Regression tests to ensure optimizations don't break functionality
- Performance benchmark comparisons between 3x3 and 4x4 boards

**Integration Testing for Performance:**
- End-to-end game performance tests with timing validations
- Computer player performance tests for decision-making speed
- State transition performance tests through multiple moves
- Factory creation performance tests for engine initialization

### Testing

### Unit Testing Strategy
[Source: docs/ui-architecture/testing-requirements.md#unit-testing]

**Performance Test Coverage Requirements:**
- 100% coverage on performance-critical engine methods (kInRow, legalMoves, isTerminal)
- Timing assertion tests for move calculation under 10ms target
- Memory allocation profiling tests for inner loop optimizations
- Lint rule validation tests for immutability pattern enforcement

**Test Categories:**

1. **Algorithm Performance Tests:**
   - K-in-row detection timing for both 3x3 and 4x4 boards
   - Move validation speed tests with full and near-empty boards
   - Terminal state detection timing across different game states
   - Computer player move calculation performance benchmarks

2. **Memory Efficiency Tests:**
   - Object allocation monitoring during critical operations
   - Array creation profiling in inner loops
   - State copying efficiency validation
   - Memory leak detection for repeated operations

3. **Immutability Validation Tests:**
   - ESLint rule enforcement verification
   - State mutation prevention tests
   - Readonly property validation
   - Functional programming pattern compliance

4. **Performance Regression Tests:**
   - Benchmark comparisons before and after optimizations
   - Performance threshold monitoring (10ms target)
   - Memory usage baseline validation
   - Algorithm complexity verification

**Test Implementation Strategy:**
```typescript
describe('Engine Performance Tests', () => {
  let engine: Engine;
  let performanceTimer: PerformanceTimer;
  
  beforeEach(() => {
    engine = EngineFactory.create3x3Engine();
    performanceTimer = new PerformanceTimer();
  });
  
  describe('Move Calculation Performance', () => {
    it('should calculate legal moves within 10ms for 3x3 board', () => {
      const gameState = engine.initialState(create3x3Config());
      
      const { result, duration } = performanceTimer.measureOperation(
        () => engine.legalMoves(gameState)
      );
      
      expect(result.length).toBe(9);
      expect(duration).toBeLessThan(10);
    });
    
    it('should calculate legal moves within 10ms for 4x4 board', () => {
      const engine4x4 = EngineFactory.create4x4Engine();
      const gameState = engine4x4.initialState(create4x4Config());
      
      const { result, duration } = performanceTimer.measureOperation(
        () => engine4x4.legalMoves(gameState)
      );
      
      expect(result.length).toBe(16);
      expect(duration).toBeLessThan(10);
    });
    
    it('should detect terminal state within 10ms', () => {
      const gameState = createNearWinState3x3(); // Test utility
      
      const { result, duration } = performanceTimer.measureOperation(
        () => engine.isTerminal(gameState)
      );
      
      expect(typeof result).toBe('boolean');
      expect(duration).toBeLessThan(10);
    });
  });
  
  describe('Memory Efficiency Tests', () => {
    it('should minimize object allocations in k-in-row detection', () => {
      const gameState = createComplexGameState3x3(); // Test utility
      
      const initialObjects = getObjectCount(); // Memory profiling utility
      engine.kInRow(gameState);
      const finalObjects = getObjectCount();
      
      // Should not create excessive objects during algorithm
      expect(finalObjects - initialObjects).toBeLessThan(5);
    });
    
    it('should reuse arrays efficiently in move validation', () => {
      const gameState = engine.initialState(create3x3Config());
      
      const initialMemory = getMemoryUsage(); // Memory profiling utility
      
      // Multiple calls should not accumulate memory
      for (let i = 0; i < 100; i++) {
        engine.legalMoves(gameState);
      }
      
      const finalMemory = getMemoryUsage();
      expect(finalMemory - initialMemory).toBeLessThan(1000); // 1KB threshold
    });
  });
  
  describe('Immutability Validation', () => {
    it('should maintain state immutability during operations', () => {
      const originalState = engine.initialState(create3x3Config());
      const stateSnapshot = JSON.stringify(originalState);
      
      // Perform operations that should not mutate original state
      engine.legalMoves(originalState);
      engine.isTerminal(originalState);
      engine.kInRow(originalState);
      
      expect(JSON.stringify(originalState)).toBe(stateSnapshot);
    });
    
    it('should pass immutability lint checks', () => {
      // This test validates that the code passes ESLint immutability rules
      const lintResults = runESLintOnEngineFiles(['immutability']);
      expect(lintResults.errorCount).toBe(0);
      expect(lintResults.warningCount).toBe(0);
    });
  });
  
  describe('Performance Regression Tests', () => {
    it('should maintain performance baselines over time', async () => {
      const benchmarks = await runPerformanceBenchmarks([
        'legal-moves-3x3',
        'legal-moves-4x4', 
        'terminal-detection',
        'k-in-row-detection'
      ]);
      
      benchmarks.forEach(benchmark => {
        expect(benchmark.averageDuration).toBeLessThan(benchmark.threshold);
        expect(benchmark.memoryUsage).toBeLessThan(benchmark.memoryThreshold);
      });
    });
  });
});
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-25 | 1.0 | Initial story creation from Epic 2.8 | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
*This section will be populated by the development agent during implementation*

### Debug Log References
*This section will be populated by the development agent during implementation*

### Completion Notes
*This section will be populated by the development agent during implementation*

### File List
*This section will be populated by the development agent during implementation*

## QA Results

*This section will be populated by the QA agent after implementation review*