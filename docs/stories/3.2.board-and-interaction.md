# Story 3.2: Board & Interaction

## Status
Reviewed

## Story
**As a** user of the tic-tac-toe application,
**I want** an interactive game board that renders the correct size, allows clicking empty cells to make moves, and provides visual feedback for game state,
**so that** I can play the game with clear current player indication and immediate feedback when the game ends with win highlighting or draw messaging.

## Acceptance Criteria
1: Grid renders correct size; clicking empty cell applies move.
2: Current player indicator updates.
3: Terminal win highlights winning line; draw shows message; disables further moves.

## Tasks / Subtasks

- [ ] **Task 1: Create Game Board Component** (AC: 1)
  - [ ] Create `GameBoardComponent` in `apps/ui/src/app/components/game-board/`
  - [ ] Implement board rendering with dynamic grid based on game configuration (3x3/4x4)
  - [ ] Setup cell rendering with proper square aspect ratio using CSS custom properties
  - [ ] Add click handlers for empty cells to trigger moves
  - [ ] Integrate with game engine through GameService for move validation and state updates
  - [ ] Apply responsive grid layout using Tailwind CSS classes

- [ ] **Task 2: Create Game Service for State Management** (AC: 1, 2)
  - [ ] Create `GameService` in `apps/ui/src/app/services/game.service.ts`
  - [ ] Implement Angular signals for reactive game state management
  - [ ] Setup engine integration using EngineFactory and GameConfig
  - [ ] Implement `makeMove(position: number)` method with move validation
  - [ ] Implement `resetGame()` method for new game functionality
  - [ ] Add computed signals for derived state (legal moves, terminal status, current player)

- [ ] **Task 3: Create Current Player Indicator Component** (AC: 2)
  - [ ] Create `GameStatusComponent` in `apps/ui/src/app/components/game-status/`
  - [ ] Display current player with clear visual indication ("X's turn" / "O's turn")
  - [ ] Show game status messages (playing, won, draw)
  - [ ] Integrate with GameService signals for reactive updates
  - [ ] Apply consistent styling with Tailwind CSS for readability

- [ ] **Task 4: Implement Win Detection and Highlighting** (AC: 3)
  - [ ] Add winning line highlighting in GameBoardComponent
  - [ ] Implement visual highlighting for winning cells using CSS classes
  - [ ] Display winner announcement in GameStatusComponent
  - [ ] Disable all cell interactions when game is terminal
  - [ ] Add celebration or victory state visual feedback

- [ ] **Task 5: Implement Draw Detection and Messaging** (AC: 3)
  - [ ] Add draw game detection using engine terminal state
  - [ ] Display draw message when board is full with no winner
  - [ ] Ensure proper game state transition to terminal status
  - [ ] Disable all cell interactions in draw state
  - [ ] Update GameStatusComponent to show draw message

- [ ] **Task 6: Integrate Board with Game Page** (AC: 1, 2, 3)
  - [ ] Update `GameComponent` to include GameBoardComponent and GameStatusComponent
  - [ ] Setup proper component layout and spacing
  - [ ] Ensure responsive behavior across mobile and desktop
  - [ ] Connect board interaction with overall game flow
  - [ ] Test integration with existing shell and routing

- [ ] **Task 7: Testing and Quality Assurance** (AC: 1, 2, 3)
  - [ ] Create unit tests for GameBoardComponent including cell clicks and rendering
  - [ ] Create unit tests for GameService including engine integration and state management
  - [ ] Create unit tests for GameStatusComponent for all game states
  - [ ] Test win scenarios with proper line highlighting
  - [ ] Test draw scenarios with proper messaging
  - [ ] Create integration tests for complete game flow
  - [ ] Add E2E tests for board interaction and game completion

## Dev Notes

### Previous Story Insights
Story 3.1 completed the UI shell and routing infrastructure. The responsive layout system is established with CSS custom properties for board sizing and Tailwind CSS responsive breakpoints. Navigation between game, health, and credits pages is functional. The game page has placeholder structure ready for board component integration.

[Source: docs/stories/3.1.ui-shell-routing.md]

### Engine Integration Context
The game engine is fully implemented and tested from Stories 2.1-2.9. Complete engine interface is available with 264 passing tests.

**Engine Factory Integration:**
[Source: libs/engine/src/lib/factories/engine-factory.ts]
```typescript
import { EngineFactory, GameConfig } from '@libs/engine';

// Engine initialization for 3x3 board
const config: GameConfig = {
  boardSize: 3,
  kInRow: 3,
  firstPlayer: 'X',
  mode: 'human-vs-human'
};
const engine = EngineFactory.createEngine(config);
```

**Core Engine Interface Methods:**
[Source: libs/engine/src/lib/interfaces/engine.interface.ts]
- `initialState(config: GameConfig): GameState` - Creates new game state
- `legalMoves(state: GameState): number[]` - Returns available positions
- `applyMove(state: GameState, move: Move): GameState` - Applies move and returns new state
- `isTerminal(state: GameState): boolean` - Checks if game is over
- `winner(state: GameState): Player | null` - Gets winner or null for draw
- `kInRow(state: GameState): number[][]` - Gets winning line positions

**Game State Structure:**
[Source: libs/shared/src/lib/types/game-state-types.ts]
```typescript
interface GameState {
  readonly board: readonly Cell[];  // Array of Cell values (null | 'X' | 'O')
  readonly currentPlayer: Player;   // 'X' | 'O'
  readonly moveHistory: readonly Move[];
  readonly status: 'playing' | 'won' | 'draw';
  readonly winner: Player | null;
  readonly winningLine: readonly number[] | null;  // Positions of winning line
  readonly config: GameConfig;
  readonly startTime: number;
  readonly endTime?: number;
}
```

**Move Interface:**
[Source: libs/shared/src/lib/types/move-types.ts]
```typescript
interface Move {
  readonly player: Player;
  readonly position: number;    // 0-based board index
  readonly timestamp: number;
}
```

### Angular Service Pattern for Game State
[Source: docs/ui-architecture/component-architecture-standards.md]

**GameService Implementation Pattern:**
```typescript
import { Injectable, signal, computed } from '@angular/core';
import { EngineFactory, Engine } from '@libs/engine';
import { GameState, GameConfig, Move, Player } from '@libs/shared';

@Injectable({
  providedIn: 'root'
})
export class GameService {
  private engine: Engine;
  private _gameState = signal<GameState | null>(null);
  
  // Public reactive state
  gameState = this._gameState.asReadonly();
  currentPlayer = computed(() => this.gameState()?.currentPlayer ?? 'X');
  board = computed(() => this.gameState()?.board ?? []);
  isTerminal = computed(() => this.gameState() ? this.engine.isTerminal(this.gameState()!) : false);
  winner = computed(() => this.gameState() ? this.engine.winner(this.gameState()!) : null);
  winningLine = computed(() => this.gameState()?.winningLine ?? null);
  legalMoves = computed(() => this.gameState() ? this.engine.legalMoves(this.gameState()!) : []);

  startNewGame(config: GameConfig): void {
    this.engine = EngineFactory.createEngine(config);
    this._gameState.set(this.engine.initialState(config));
  }

  makeMove(position: number): boolean {
    const currentState = this.gameState();
    if (!currentState || this.isTerminal()) return false;
    
    try {
      const move: Move = {
        player: currentState.currentPlayer,
        position,
        timestamp: Date.now()
      };
      const newState = this.engine.applyMove(currentState, move);
      this._gameState.set(newState);
      return true;
    } catch (error) {
      console.error('Invalid move:', error);
      return false;
    }
  }
}
```

### Component Architecture Standards
[Source: docs/ui-architecture/component-architecture-standards.md]

**GameBoardComponent Implementation Pattern:**
```typescript
import { Component, ChangeDetectionStrategy, inject, computed } from '@angular/core';
import { CommonModule } from '@angular/common';
import { GameService } from '../../services/game.service';

@Component({
  selector: 'app-game-board',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div 
      class="game-board" 
      [class.board-3x3]="boardSize() === 3"
      [class.board-4x4]="boardSize() === 4"
      data-testid="game-board"
    >
      @for (cell of board(); track $index) {
        <button
          class="cell"
          [class.occupied]="cell !== null"
          [class.winning]="isWinningCell($index)"
          [disabled]="isTerminal() || cell !== null"
          (click)="handleCellClick($index)"
          [attr.data-testid]="'cell-' + $index"
          [attr.aria-label]="getCellAriaLabel($index)"
        >
          {{ cell || '' }}
        </button>
      }
    </div>
  `,
  styleUrl: './game-board.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class GameBoardComponent {
  private gameService = inject(GameService);
  
  // Reactive state from service
  board = this.gameService.board;
  boardSize = computed(() => Math.sqrt(this.board().length));
  isTerminal = this.gameService.isTerminal;
  winningLine = this.gameService.winningLine;
  
  handleCellClick(position: number): void {
    this.gameService.makeMove(position);
  }
  
  isWinningCell(position: number): boolean {
    const winningLine = this.winningLine();
    return winningLine ? winningLine.includes(position) : false;
  }
  
  getCellAriaLabel(position: number): string {
    const cell = this.board()[position];
    const row = Math.floor(position / this.boardSize()) + 1;
    const col = (position % this.boardSize()) + 1;
    
    if (cell) {
      return `Cell row ${row} column ${col}, occupied by ${cell}`;
    }
    return `Cell row ${row} column ${col}, empty, click to place mark`;
  }
}
```

### Responsive Board Styling
[Source: docs/stories/3.1.ui-shell-routing.md - CSS custom properties system]

**Board Styling Implementation:**
```scss
// game-board.component.scss
.game-board {
  @apply grid gap-2 p-4 bg-white rounded-lg shadow-lg mx-auto;
  
  width: var(--game-board-size);
  height: var(--game-board-size);
  
  &.board-3x3 {
    @apply grid-cols-3;
  }
  
  &.board-4x4 {
    @apply grid-cols-4;
  }
}

.cell {
  @apply bg-gray-100 border-2 border-gray-300 rounded-md text-3xl font-bold
         hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500
         transition-colors duration-150 flex items-center justify-center;
  
  aspect-ratio: 1;
  min-height: var(--cell-size);
  
  &:disabled {
    @apply cursor-not-allowed opacity-60;
  }
  
  &.occupied {
    @apply bg-gray-200 cursor-not-allowed;
  }
  
  &.winning {
    @apply bg-green-200 border-green-400 text-green-800;
  }
}

// CSS Custom Properties (already established in globals.scss)
:root {
  --game-board-size: 300px;
  --cell-size: calc(var(--game-board-size) / var(--board-dimension));
  --board-dimension: 3;
  
  @media (max-width: 640px) {
    --game-board-size: 280px;
  }
  
  @media (max-width: 480px) {
    --game-board-size: 260px;
  }
}

.board-4x4 {
  --board-dimension: 4;
}
```

### File Locations and Structure
[Source: docs/ui-architecture/project-structure.md]

**New Files to Create:**
- `apps/ui/src/app/components/game-board/game-board.component.ts` - Interactive board component
- `apps/ui/src/app/components/game-board/game-board.component.html` - Board template
- `apps/ui/src/app/components/game-board/game-board.component.scss` - Board styles
- `apps/ui/src/app/components/game-board/game-board.component.spec.ts` - Board tests
- `apps/ui/src/app/components/game-status/game-status.component.ts` - Status display component
- `apps/ui/src/app/components/game-status/game-status.component.html` - Status template
- `apps/ui/src/app/components/game-status/game-status.component.scss` - Status styles
- `apps/ui/src/app/components/game-status/game-status.component.spec.ts` - Status tests
- `apps/ui/src/app/services/game.service.ts` - Game state management service
- `apps/ui/src/app/services/game.service.spec.ts` - Service tests

**Files to Update:**
- `apps/ui/src/app/pages/game/game.component.ts` - Integrate board and status components
- `apps/ui/src/app/pages/game/game.component.html` - Add components to template
- `apps/ui/src/app/pages/game/game.component.scss` - Layout styles for components

**Existing Files to Reference:**
- `libs/engine/src/index.ts` - Engine public API
- `libs/shared/src/index.ts` - Shared types and interfaces
- `apps/ui/src/styles/globals.scss` - CSS custom properties (already setup)

### Current Project Context
[Source: Review of current game page from Story 3.1]

**Existing Game Page Structure:**
The game page currently has placeholder structure from Story 3.1 with:
- Centered board container ready for board component
- Inline controls area (will be used in Story 3.3)
- Responsive layout with CSS custom properties
- Navigation and routing working

**Integration Points:**
- Board component will replace placeholder in game page
- Status component will integrate with existing layout
- Game service will be injected into components for state management
- Responsive system already supports 3x3 and 4x4 layouts

### Testing

#### Testing Standards
[Source: docs/ui-architecture/component-architecture-standards.md]

**Unit Testing Requirements:**
- **Framework**: Jest with Angular testing utilities
- **Location**: Test files co-located with components (`.spec.ts`)
- **Coverage**: All public component methods, click handlers, and reactive state
- **Patterns**: Use Angular Testing Library for user-centric testing approach

**GameBoardComponent Testing Strategy:**
```typescript
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { GameBoardComponent } from './game-board.component';
import { GameService } from '../../services/game.service';

describe('GameBoardComponent', () => {
  let component: GameBoardComponent;
  let fixture: ComponentFixture<GameBoardComponent>;
  let gameService: jasmine.SpyObj<GameService>;

  beforeEach(async () => {
    const gameServiceSpy = jasmine.createSpyObj('GameService', ['makeMove'], {
      board: signal([null, null, null, null, null, null, null, null, null]),
      isTerminal: signal(false),
      winningLine: signal(null)
    });

    await TestBed.configureTestingModule({
      imports: [GameBoardComponent],
      providers: [{ provide: GameService, useValue: gameServiceSpy }]
    }).compileComponents();

    fixture = TestBed.createComponent(GameBoardComponent);
    component = fixture.componentInstance;
    gameService = TestBed.inject(GameService) as jasmine.SpyObj<GameService>;
    fixture.detectChanges();
  });

  it('should render 9 cells for 3x3 board', () => {
    const cells = fixture.nativeElement.querySelectorAll('[data-testid^="cell-"]');
    expect(cells.length).toBe(9);
  });

  it('should call makeMove when empty cell is clicked', () => {
    const cell = fixture.nativeElement.querySelector('[data-testid="cell-0"]');
    cell.click();
    expect(gameService.makeMove).toHaveBeenCalledWith(0);
  });

  it('should highlight winning cells', () => {
    gameService.winningLine = signal([0, 1, 2]);
    fixture.detectChanges();
    
    const winningCells = fixture.nativeElement.querySelectorAll('.winning');
    expect(winningCells.length).toBe(3);
  });

  it('should disable all cells when game is terminal', () => {
    gameService.isTerminal = signal(true);
    fixture.detectChanges();
    
    const cells = fixture.nativeElement.querySelectorAll('button[disabled]');
    expect(cells.length).toBe(9);
  });
});
```

**GameService Testing Strategy:**
```typescript
describe('GameService', () => {
  let service: GameService;
  let mockEngine: jasmine.SpyObj<Engine>;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(GameService);
  });

  it('should start new game with correct configuration', () => {
    const config: GameConfig = {
      boardSize: 3,
      kInRow: 3,
      firstPlayer: 'X',
      mode: 'human-vs-human'
    };
    
    service.startNewGame(config);
    
    expect(service.gameState()).toBeTruthy();
    expect(service.currentPlayer()).toBe('X');
  });

  it('should make valid moves and update state', () => {
    const config: GameConfig = {
      boardSize: 3,
      kInRow: 3,
      firstPlayer: 'X',
      mode: 'human-vs-human'
    };
    service.startNewGame(config);
    
    const result = service.makeMove(0);
    
    expect(result).toBe(true);
    expect(service.board()[0]).toBe('X');
    expect(service.currentPlayer()).toBe('O');
  });

  it('should reject invalid moves', () => {
    const config: GameConfig = {
      boardSize: 3,
      kInRow: 3,
      firstPlayer: 'X',
      mode: 'human-vs-human'
    };
    service.startNewGame(config);
    
    service.makeMove(0); // Place X
    const result = service.makeMove(0); // Try to place O in same position
    
    expect(result).toBe(false);
  });
});
```

**Integration Testing Requirements:**
- Test complete game flow from start to finish
- Test win scenarios with proper highlighting
- Test draw scenarios with proper messaging
- Test responsive behavior at different screen sizes
- Test accessibility features (ARIA labels, keyboard navigation)

**E2E Testing Strategy:**
```typescript
// apps/ui-e2e/src/game-board.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Game Board Interaction', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
  });

  test('should allow clicking empty cells to make moves', async ({ page }) => {
    // Click first cell
    await page.click('[data-testid="cell-0"]');
    await expect(page.locator('[data-testid="cell-0"]')).toHaveText('X');
    
    // Click second cell
    await page.click('[data-testid="cell-1"]');
    await expect(page.locator('[data-testid="cell-1"]')).toHaveText('O');
  });

  test('should show current player indicator', async ({ page }) => {
    await expect(page.locator('[data-testid="current-player"]')).toContainText("X's turn");
    
    await page.click('[data-testid="cell-0"]');
    await expect(page.locator('[data-testid="current-player"]')).toContainText("O's turn");
  });

  test('should highlight winning line and disable board', async ({ page }) => {
    // Play a winning game: X wins with top row
    await page.click('[data-testid="cell-0"]'); // X
    await page.click('[data-testid="cell-3"]'); // O
    await page.click('[data-testid="cell-1"]'); // X
    await page.click('[data-testid="cell-4"]'); // O
    await page.click('[data-testid="cell-2"]'); // X wins
    
    // Check winning line is highlighted
    await expect(page.locator('[data-testid="cell-0"]')).toHaveClass(/winning/);
    await expect(page.locator('[data-testid="cell-1"]')).toHaveClass(/winning/);
    await expect(page.locator('[data-testid="cell-2"]')).toHaveClass(/winning/);
    
    // Check winner message
    await expect(page.locator('[data-testid="game-status"]')).toContainText('X wins!');
    
    // Check all cells are disabled
    const enabledCells = await page.locator('button:not([disabled])').count();
    expect(enabledCells).toBe(0);
  });

  test('should show draw message when board is full', async ({ page }) => {
    // Play a draw game (specific sequence that results in draw)
    const drawSequence = [0, 1, 2, 4, 3, 5, 7, 6, 8];
    for (const position of drawSequence) {
      await page.click(`[data-testid="cell-${position}"]`);
    }
    
    await expect(page.locator('[data-testid="game-status"]')).toContainText('Draw!');
  });
});
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-25 | 1.0 | Initial story creation from Epic 3.2 | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
*This section will be populated by the development agent during implementation*

### Debug Log References
*This section will be populated by the development agent during implementation*

### Completion Notes
*This section will be populated by the development agent during implementation*

### File List
*This section will be populated by the development agent during implementation*

## QA Results

*This section will be populated by the QA agent after implementation review*