# Story 5.1: Integration Test Suite

## Status
Draft

## Story
**As a** development team member,
**I want** comprehensive integration tests that validate the complete interaction between UI components, game engine, and computer opponent,
**so that** we can ensure the system works cohesively across move sequences, win detection, and draw scenarios without manual testing.

## Acceptance Criteria
1: Integration tests cover: move application sequence (X human then computer optimal reply), win detection highlight, draw scenario creation (3x3 & 4x4).
2: No accessibility assertions required.

## Tasks / Subtasks

- [ ] **Task 1: Integration Test Infrastructure Setup** (AC: 1)
  - [ ] Create integration test configuration for UI+Engine combination testing
  - [ ] Set up test utilities for simulating complete human-computer move sequences
  - [ ] Configure test environment to support both 3x3 and 4x4 board scenarios
  - [ ] Implement test helpers for board state verification and move sequence validation

- [ ] **Task 2: Human-Computer Move Sequence Integration Tests** (AC: 1)
  - [ ] Create test case for human X move followed by optimal computer O reply validation
  - [ ] Test complete move alternation sequences with state consistency verification
  - [ ] Validate that computer moves are deterministic and strategically sound
  - [ ] Ensure proper player turn alternation throughout the game sequence
  - [ ] Test move validation integration between UI and engine layers

- [ ] **Task 3: Win Detection and Highlighting Integration Tests** (AC: 1)
  - [ ] Test win condition detection across UI and engine integration for 3x3 boards
  - [ ] Test win condition detection across UI and engine integration for 4x4 boards
  - [ ] Validate winning line highlighting in UI when engine detects wins
  - [ ] Test terminal state handling when game transitions from playing to won
  - [ ] Verify winner display and game state finalization integration

- [ ] **Task 4: Draw Scenario Integration Tests** (AC: 1)
  - [ ] Create 3x3 draw scenario tests with full board completion
  - [ ] Create 4x4 draw scenario tests with full board completion
  - [ ] Test draw detection when no winner exists and board is full
  - [ ] Validate draw state display and game termination handling
  - [ ] Test that no further moves are accepted after draw detection

- [ ] **Task 5: Cross-Board Size Integration Validation** (AC: 1)
  - [ ] Test game mode switching between 3x3 and 4x4 with state reset
  - [ ] Validate that integration tests pass for both board sizes consistently
  - [ ] Test computer opponent strategy adaptation across different board sizes
  - [ ] Ensure UI components handle board size changes correctly in integration scenarios

## Dev Notes

### Previous Story Insights
Story 4.5 established comprehensive bundle size documentation with production build validation. All build processes and production optimization are confirmed working correctly with Angular 17+ and Vite build system. Previous stories have established solid unit testing foundation for engine library and component-level testing for UI elements.

[Source: docs/stories/4.5.bundle-size-note.md]

### Integration Testing Architecture Strategy
[Source: docs/architecture/ADR-002-project-structure.md#testing-strategy-by-layer]

**Testing Layer Separation and Integration Points:**
- **Engine Library**: Pure unit tests with 100% coverage of game logic (already established)
- **UI Components**: Integration tests with @testing-library/angular (existing)
- **Application Layer**: End-to-end tests covering complete user workflows (Playwright)
- **Integration Layer**: NEW - Tests that validate interaction between engine and UI without full E2E overhead

**Integration Test Positioning:**
Integration tests sit between unit tests (pure logic) and E2E tests (browser automation). They test the interaction between Angular services, game engine, and UI state management without requiring browser automation or user interaction simulation.

**Test File Location and Naming Convention:**
- **Location**: `apps/ui/src/app/integration/` directory for UI-Engine integration tests
- **Naming Pattern**: `*.integration.spec.ts` to distinguish from unit tests and E2E tests
- **Target**: Angular services and game engine interaction without browser rendering

### Technology Stack for Integration Testing
[Source: docs/architecture/ADR-001-tech-stack.md#testing-infrastructure, docs/ui-architecture/frontend-tech-stack.md]

**Testing Framework Configuration:**
- **Jest**: Primary testing framework for integration tests (same as unit tests)
- **@testing-library/angular**: Component integration testing utilities for Angular services
- **Angular Testing Utilities**: TestBed for service and component interaction testing
- **TypeScript 5.x**: Type safety for test scenarios and mocking

**Testing Tools Available:**
- **Jest**: Fast test execution with excellent Angular integration and mocking capabilities
- **Testing Library**: User-centric testing approach promotes maintainable integration tests
- **Angular Signals**: Built-in reactivity testing with signal-based state verification
- **Angular Services**: Dependency injection testing for game service and engine integration

### Game Engine Integration Points
[Source: docs/architecture/ADR-002-project-structure.md#game-engine-as-separate-library]

**Engine-UI Integration Architecture:**
- **Framework Independence**: Game logic works with any frontend framework via clear interfaces
- **Pure Functions**: Engine methods are deterministic and easily testable in integration scenarios
- **Business Logic Isolation**: UI concerns separated from game rules and validation
- **Service Layer Integration**: Angular GameService acts as adapter between UI and engine

**Integration Test Focus Areas:**
```typescript
// Integration points to test:
GameService <-> GameEngine (move processing, state management)
GameService <-> ComputerPlayer (AI move calculation and integration)
UI Components <-> GameService (state updates, move handling)
Board Size Configuration <-> Engine Initialization
Win Detection <-> UI State Updates
```

**Key Integration Interfaces:**
- **GameService.makeMove()**: UI to engine move processing integration
- **GameService.resetGame()**: Game state initialization and cleanup
- **GameService.gameState()**: Signal-based state synchronization between layers
- **ComputerPlayer.calculateNextMove()**: AI integration with current game state

### Integration Testing Data Models and State Management
[Source: docs/architecture/ADR-002-project-structure.md, libs/shared/src/lib/types/game-types.ts]

**State Management Integration Points:**
```typescript
// Core types for integration testing:
type Player = 'X' | 'O';
type Cell = Player | null;
type BoardSize = 3 | 4;
type GameMode = 'human-vs-human' | 'human-vs-computer' | 'computer-vs-computer';

// Game state interface integration:
interface GameState {
  board: Cell[];
  currentPlayer: Player;
  moveHistory: Move[];
  status: 'playing' | 'won' | 'draw';
  winner: Player | null;
  winningLine: number[] | null;
  boardSize: BoardSize;
  gameMode: GameMode;
}
```

**Integration Test State Validation:**
- **State Consistency**: Ensure UI state matches engine state after each move
- **Move History Tracking**: Validate move sequence recording and playback
- **Win Line Highlighting**: Test UI highlighting matches engine win detection
- **Board Size Handling**: Validate state management across 3x3 and 4x4 boards

### Angular Service Layer Integration Testing
[Source: docs/ui-architecture/component-architecture-standards.md, docs/architecture/ADR-001-tech-stack.md]

**Angular Service Integration Points:**
```typescript
// GameService integration methods to test:
export class GameService {
  // Signal-based state management
  gameState = signal<GameState>(initialState);
  
  // Integration methods requiring testing:
  makeMove(position: number): void;
  resetGame(size?: BoardSize, mode?: GameMode): void;
  getAvailableMoves(): number[];
  isGameComplete(): boolean;
  calculateComputerMove(): number;
}
```

**Testing Framework Integration:**
- **Angular TestBed**: Service instantiation and dependency injection testing
- **Signal Testing**: Reactive state change validation using Angular 17+ signals
- **Mock Integration**: Engine and computer player mocking for isolated integration tests
- **Change Detection**: OnPush change detection strategy testing with state updates

### Integration Test Scenarios and Coverage Requirements
[Source: docs/prd/epic-5-integration-e2e-testing.md]

**Required Integration Test Coverage:**

**1. Move Application Sequence Testing:**
- Human move (X) → Engine validation → State update → Computer move (O) → Engine validation → State update
- Test sequence: UI click → GameService.makeMove() → GameEngine.processMove() → State signal update → Computer response
- Validation: Move history accuracy, turn alternation, state consistency

**2. Win Detection Integration Testing:**
- Engine win detection → GameService state update → UI component win highlighting
- Test both 3x3 and 4x4 win scenarios with proper winning line identification
- Validation: UI highlighting matches engine winning line, game termination handling

**3. Draw Scenario Integration Testing:**
- Full board completion → Engine draw detection → GameService state update → UI draw display
- Test board-full scenarios for both 3x3 and 4x4 boards
- Validation: No further moves accepted, proper draw state communication

**Integration Test Performance Expectations:**
- Tests should execute rapidly without browser automation overhead
- Each integration test should complete in <100ms per scenario
- Total integration test suite should complete in <5 seconds
- Focus on state transition validation rather than UI rendering performance

### File Structure and Project Integration
[Source: docs/architecture/ADR-002-project-structure.md#ui-application-structure]

**Integration Test File Organization:**
```
apps/ui/src/app/
├── integration/                    # NEW - Integration test directory
│   ├── game-engine.integration.spec.ts    # Engine-Service integration tests
│   ├── computer-player.integration.spec.ts # AI-Service integration tests
│   ├── game-flow.integration.spec.ts       # Complete game flow integration
│   └── board-size.integration.spec.ts      # Multi-size board integration
├── services/
│   ├── game.service.ts            # Primary integration point
│   └── game.service.spec.ts       # Unit tests for service
```

**Integration with Existing Test Infrastructure:**
- **Jest Configuration**: Use existing Jest setup from `apps/ui/jest.config.ts`
- **Test Scripts**: Integrate with existing `pnpm nx test ui` command
- **Coverage Reporting**: Include integration tests in overall coverage metrics
- **CI/CD Integration**: Run integration tests as part of automated testing pipeline

### Testing Standards and Quality Requirements
[Source: docs/architecture/ADR-001-tech-stack.md#testing-infrastructure]

**Integration Testing Standards:**
- **Test Isolation**: Each integration test should be independent and not rely on test order
- **State Cleanup**: Proper test setup and teardown to prevent state leakage between tests
- **Deterministic Results**: Tests should produce consistent results across multiple runs
- **Error Handling**: Test both success and failure scenarios for robust integration validation

**Integration Test Quality Gates:**
- **Coverage Target**: 100% coverage of integration points between UI and engine
- **Performance Target**: Integration test suite completes in <5 seconds
- **Reliability Target**: Tests pass consistently without flaky behavior
- **Maintainability**: Tests use clear naming and documentation for future maintenance

**Testing Framework Best Practices:**
```typescript
// Integration test structure template:
describe('GameService and GameEngine Integration', () => {
  let gameService: GameService;
  let gameEngine: GameEngine;
  let computerPlayer: ComputerPlayer;

  beforeEach(() => {
    TestBed.configure({
      providers: [GameService, GameEngine, ComputerPlayer]
    });
    gameService = TestBed.inject(GameService);
    gameEngine = TestBed.inject(GameEngine);
    computerPlayer = TestBed.inject(ComputerPlayer);
  });

  it('should integrate human and computer moves correctly', () => {
    // Test implementation
  });
});
```

## Testing

### Integration Testing Implementation Standards
[Source: docs/architecture/ADR-001-tech-stack.md#testing-infrastructure]

**Integration Test Execution Environment:**
- **Framework**: Jest with Angular Testing Utilities for service and component integration
- **Location**: `apps/ui/src/app/integration/*.integration.spec.ts`
- **Command**: `pnpm nx test ui --testNamePattern="integration"` for targeted integration test execution
- **Coverage**: Integration tests included in overall code coverage reporting

**Integration Test Structure Requirements:**
```typescript
// Required test structure for integration tests:
describe('[Component/Service] Integration', () => {
  // Angular TestBed setup for dependency injection
  beforeEach(() => {
    TestBed.configureTestingModule({
      // Service and component configuration
    });
  });

  // Test scenarios covering AC requirements
  it('should validate move sequence integration', () => {
    // Human move → Computer response integration test
  });

  it('should validate win detection integration', () => {
    // Engine detection → UI highlighting integration test
  });

  it('should validate draw scenario integration', () => {
    // Full board → Draw detection → UI update integration test
  });
});
```

**Test Data and Scenario Management:**
- **Predefined Scenarios**: Create reusable game state fixtures for consistent testing
- **Board Configurations**: Test data for both 3x3 and 4x4 board scenarios
- **Move Sequences**: Predefined move sequences for win, draw, and ongoing game scenarios
- **State Validation**: Helper functions for verifying integration state consistency

**Integration Test Validation Criteria:**
- **State Synchronization**: UI state matches engine state after each integration operation
- **Move Processing**: Complete move flow from UI interaction to engine processing to state update
- **Win/Draw Detection**: Integration between engine detection and UI state/display updates
- **Computer Player Integration**: AI move calculation integration with game service and state management
- **Board Size Handling**: Integration tests pass consistently for both 3x3 and 4x4 board configurations

**Performance and Reliability Standards:**
- **Execution Time**: Each integration test scenario completes in <100ms
- **Suite Performance**: Complete integration test suite executes in <5 seconds
- **Test Isolation**: Tests do not depend on execution order or shared state
- **Deterministic Results**: Integration tests produce consistent results across multiple runs
- **Error Scenarios**: Tests validate both success paths and error handling in integration points

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-27 | 1.0 | Initial story creation from Epic 5.1 | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
*This section will be populated by the development agent during implementation*

### Debug Log References
*This section will be populated by the development agent during implementation*

### Completion Notes
*This section will be populated by the development agent during implementation*

### File List
*This section will be populated by the development agent during implementation*

## QA Results

*This section will be populated by the QA agent after implementation review*